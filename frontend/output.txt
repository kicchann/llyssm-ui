--- /workspaces/lyssm-ui/frontend/src/App.test.tsx ---
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- /workspaces/lyssm-ui/frontend/src/App.tsx ---
import React from 'react';
import { Provider } from 'react-redux'; // Redux Provider のインポート
import { Route, BrowserRouter as Router, Routes } from 'react-router-dom';
import { routes } from './routes/routes';
import store from './store/store'; // Redux ストアのインポート

const App: React.FC = () => {
  return (
    // Redux の Provider でアプリ全体をラップ
    <Provider store={store}>
      <Router>
        <Routes>
          {routes.map((route, index) => (
            <Route key={index} path={route.path} element={route.element} />
          ))}
        </Routes>
      </Router>
    </Provider>
  );
};

export default App;


--- /workspaces/lyssm-ui/frontend/src/components/atoms/ErrorSnackbar.tsx ---
import { Alert, Snackbar } from '@mui/material';
import React from 'react';

// TODO: このコンポーネントは、エラーメッセージを表示するSnackbarです。
// TODO: あとで実装します。

interface ErrorSnackbarProps {
  open: boolean;
  message: string;
  onClose: () => void;
}

export const ErrorSnackbar: React.FC<ErrorSnackbarProps> = ({
  open,
  message,
  onClose,
}) => {
  return (
    <Snackbar open={open} autoHideDuration={6000} onClose={onClose}>
      <Alert onClose={onClose} severity="error">
        {message}
      </Alert>
    </Snackbar>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/atoms/Label.tsx ---
// src/components/atoms/Label.tsx
import { Typography } from '@mui/material';
import React from 'react';

interface LabelProps {
  text: string;
  color?: string;
}

export const Label: React.FC<LabelProps> = ({ text, color = 'black' }) => (
  <Typography style={{ color }}>{text}</Typography>
);


--- /workspaces/lyssm-ui/frontend/src/components/molecules/CustomTooltip.tsx ---
import React from 'react';
import styled from 'styled-components';
import { MarkerData } from '../../types/map';

// スタイルの定義
// CustomTooltipはあとで静的なHTMLとして描画するため、styled-componentsを使ってスタイルを定義
// MUIは使わない
const StyledWrapper = styled.div`
  max-width: none;
  padding: 0;
  box-shadow: 0 0 0 2px white;
`;

const StyledImage = styled.img`
  width: 100%;
  border-radius: 4px 4px 0 0;
  padding: 30;
`;

const StyledContent = styled.article`
  margin: 1rem;
  text-align: justify;
`;

const StyledTitle = styled.h2`
  margin: 0;
`;

const StyledText = styled.p`
  margin: 0;
`;

interface CustomTooltipProps {
  markerData: MarkerData;
}

export const CustomTooltip: React.FC<CustomTooltipProps> = ({ markerData }) => {
  return (
    <>
      {/* Tooltip内容 */}
      <StyledWrapper className="custom-tooltip">
        <StyledImage src={markerData.thumbnailUrl} alt={markerData.name} />
        <StyledContent>
          <StyledTitle>{markerData.name}</StyledTitle>
          <StyledText>{markerData.description}</StyledText>
        </StyledContent>
      </StyledWrapper>
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/DrawerNode.tsx ---
import { Layers } from '@mui/icons-material';
import CloseIcon from '@mui/icons-material/Close';
import { Box, Drawer, IconButton } from '@mui/material';
import { styled } from '@mui/styles';
import React, { useState } from 'react';

const DrawerBox = styled(Box)({
  width: 300,
  padding: 16,
  paddingTop: 48, // 閉じるボタン分のスペースを確保
  position: 'relative',
});

const CloseButtonBox = styled(Box)({
  position: 'absolute',
  top: 8, // ボタンを右上に固定
  right: 8,
});

interface DrawerNodeProps {
  content: React.ReactNode;
}

export const DrawerNode: React.FC<DrawerNodeProps> = ({ content }) => {
  const [isOpen, setIsOpen] = useState(false);

  const toggleDrawer = (open: boolean) => () => {
    setIsOpen(open);
  };

  return (
    <>
      {/* メニューを開くボタン */}
      <IconButton onClick={toggleDrawer(true)} color="inherit">
        <Layers />
      </IconButton>

      {/* 右からスライドするメニュー */}
      <Drawer anchor="right" open={isOpen} onClose={toggleDrawer(false)}>
        <DrawerBox role="presentation">
          {/* 閉じるボタン */}
          <CloseButtonBox>
            <IconButton onClick={toggleDrawer(false)}>
              <CloseIcon />
            </IconButton>
          </CloseButtonBox>
          {content}
        </DrawerBox>
      </Drawer>
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/LayerTileGridButton.tsx ---
import styled from '@emotion/styled';
import { GridView } from '@mui/icons-material';
import { IconButton } from '@mui/material';
import React from 'react';

interface LayerTileGridButtonProps {
  onClick?: () => void;
}

const StyledIconButton = styled(IconButton)({
  backgroundColor: 'rgba(255, 255, 255, 0.5)',
});

export const LayerTileGridButton: React.FC<LayerTileGridButtonProps> = ({
  onClick,
}) => {
  return (
    <StyledIconButton onClick={onClick} title="レイヤー一覧">
      <GridView />
    </StyledIconButton>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/LocationTooltip.tsx ---
import { Box } from '@mui/material';
import 'leaflet/dist/leaflet.css';
import React from 'react';
import { Marker, Popup } from 'react-leaflet';
import { LocationData } from '../../types/map';
import { getLocationIcon } from '../../utils/mapUtils';

interface LocationTooltipProps {
  locationData: LocationData;
  onClick: (event: React.MouseEvent, itemId: string) => void;
}

export const LocationTooltip: React.FC<LocationTooltipProps> = ({
  locationData: data,
  onClick: onPopupClick,
}) => {
  return (
    <Marker
      position={[data.geoLocation.latitude, data.geoLocation.longitude]}
      icon={getLocationIcon(data.iconType)}
    >
      <Popup>
        <Box onClick={(event) => onPopupClick(event, data.id)}>
          <h3>{data.name}</h3>
          <p>{data.description}</p>
          <p>クリックで詳細ページへ</p>
        </Box>
      </Popup>
    </Marker>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/ModalNode.tsx ---
import CloseIcon from '@mui/icons-material/Close';
import { Box, IconButton, Modal } from '@mui/material';
import { styled } from '@mui/system';
import React, { useEffect } from 'react';

interface ModalNodeProps {
  open: boolean;
  onClose: () => void;
  content: React.ReactNode;
}

const StyledModalBox = styled(Box)({
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  width: '85%',
  maxWidth: '800px',
  bgcolor: 'rgba(0, 0, 0, 0.2)',
  p: 1,
  maxHeight: '90vh',
  overflowY: 'auto',
  paddingTop: 36, // 閉じるボタン分のスペースを確保
});

const StyledIconButton = styled(IconButton)({
  position: 'absolute',
  top: 0,
  right: 0,
  color: 'white',
});

export const ModalNode: React.FC<ModalNodeProps> = ({
  open,
  onClose,
  content,
}) => {
  // ESCキーでモーダルを閉じる
  useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEsc);

    return () => {
      document.removeEventListener('keydown', handleEsc);
    };
  }, [onClose]);

  return (
    <Modal
      open={open}
      onClose={onClose}
      aria-labelledby="marker-modal-title"
      aria-describedby="marker-modal-description"
    >
      <StyledModalBox>
        <StyledIconButton onClick={onClose}>
          <CloseIcon />
        </StyledIconButton>
        {content}
      </StyledModalBox>
    </Modal>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/SettingMenu.tsx ---
import { MoreVert } from '@mui/icons-material';
import { IconButton } from '@mui/material';
import React from 'react';
import { useNavigate } from 'react-router-dom';

export const MoreMenu: React.FC = () => {
  const navigate = useNavigate();

  const handleSettingsClick = () => {
    navigate('/setting');
  };

  return (
    <IconButton
      edge="start"
      color="inherit"
      aria-label="menu"
      onClick={handleSettingsClick}
    >
      <MoreVert />
    </IconButton>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/Sidebar.tsx ---
// import styled from 'styled-components';
import { styled } from '@mui/system';

const SidebarWrapper = styled('div')({
  display: 'flex',
  flexDirection: 'row',
  position: 'relative',
});

const SidebarContainer = styled('div')<{ isOpen: boolean }>(({ isOpen }) => ({
  overflowY: 'auto',
  backgroundColor: '#fff',
  transition: 'width 0.3s ease, padding 0.3s ease',
  boxShadow: isOpen ? '2px 0 5px rgba(0, 0, 0, 0.1)' : 'none',
  width: isOpen ? 'var(--sidebar-width, 300px)' : '0',
  padding: isOpen ? '10px' : '0',
  '@media (max-width: 768px)': {
    width: isOpen ? '100%' : '0',
  },
}));

interface SidebarProps {
  isOpen: boolean;
  content: React.ReactNode;
}

export const Sidebar: React.FC<SidebarProps> = ({ isOpen, content }) => {
  return (
    <SidebarWrapper>
      <SidebarContainer isOpen={isOpen} aria-hidden={!isOpen} role="region">
        {content}
      </SidebarContainer>
    </SidebarWrapper>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/ToggleSidebarButton.tsx ---
import styled from '@emotion/styled';
import {
  KeyboardDoubleArrowLeft,
  KeyboardDoubleArrowRight,
} from '@mui/icons-material';
import { IconButton } from '@mui/material';
import React from 'react';

interface ToggleSidebarButtonProps {
  isSidebarOpen: boolean;
  onToggle: () => void;
}

const StyledIconButton = styled(IconButton)({
  backgroundColor: 'rgba(255, 255, 255, 0.5)',
});

export const ToggleSidebarButton: React.FC<ToggleSidebarButtonProps> = ({
  isSidebarOpen,
  onToggle,
}) => {
  return (
    <StyledIconButton onClick={onToggle}>
      {isSidebarOpen ? (
        <KeyboardDoubleArrowLeft />
      ) : (
        <KeyboardDoubleArrowRight />
      )}
    </StyledIconButton>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/TreeNode.tsx ---
import { TreeItem } from '@mui/x-tree-view/TreeItem';
import React from 'react';

interface TreeNodeProps {
  id: string;
  label: string;
  children?: React.ReactNode;
  onItemClick: (event: React.SyntheticEvent, itemId: string) => void;
  isSelected?: boolean;
}

export const TreeNode: React.FC<TreeNodeProps> = ({
  id,
  label,
  children,
  onItemClick,
  isSelected,
}) => {
  return (
    <TreeItem
      key={id}
      itemId={id}
      label={label}
      onClick={(event) => onItemClick(event, id)}
      sx={
        {
          backgroundColor: isSelected ? 'rgba(0, 0, 0, 0.1)' : 'transparent',
          color: 'black',
        }
      }
    >
      {children}
    </TreeItem>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/YawPitchDisplay.tsx ---
import { Box, styled } from '@mui/material';
import React from 'react';
import { Label } from '../atoms/Label';

interface YawPitchDisplayProps {
  yaw: number;
  pitch: number;
}

const StyledBox = styled(Box)({
  position: 'absolute',
  bottom: 45,
  right: 10,
  backgroundColor: 'rgba(0, 0, 0, 0.5)',
  padding: '5px 10px',
  borderRadius: '5px',
});

export const YawPitchDisplay: React.FC<YawPitchDisplayProps> = ({
  yaw,
  pitch,
}) => {
  return (
    <StyledBox>
      <Label text={`Yaw: ${yaw.toFixed(1)}°`} color="white" />
      <Label text={`Pitch: ${pitch.toFixed(1)}°`} color="white" />
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/HeaderBase.tsx ---
import { AppBar, Toolbar, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import React from 'react';
import { DrawerNode } from '../molecules/DrawerNode';
import { MoreMenu } from '../molecules/SettingMenu';
import { TreeList } from './TreeList';

interface HeaderBaseProps {
  isDesktop: boolean;
}

const HeaderBase: React.FC<HeaderBaseProps> = ({ isDesktop }) => {
  const StyledTypography = styled(Typography)({
    flexGrow: 1,
  });

  return (
    <AppBar position="static">
      <Toolbar>
        <StyledTypography variant="h6">View Page</StyledTypography>
        {!isDesktop && <DrawerNode content={<TreeList />} />}
        <MoreMenu />
      </Toolbar>
    </AppBar>
  );
};

export const Header: React.FC = () => <HeaderBase isDesktop={true} />;
export const CompactHeader: React.FC = () => <HeaderBase isDesktop={false} />;


--- /workspaces/lyssm-ui/frontend/src/components/organisms/LayerTileGrid.tsx ---
import { Card, CardContent, CardMedia, Grid2, Typography } from '@mui/material';
import React from 'react';
import { useLayerTileGridViewModel } from '../../viewModels/LayerTileGridViewModel';

export const LayerTileGrid: React.FC = () => {
  const { layerDataList, handleLayerClick } = useLayerTileGridViewModel();
  return (
    <Grid2
      container
      spacing={{ xs: 2, md: 3 }}
      columns={{ xs: 4, sm: 8, md: 12 }}
      padding={2}
    >
      {layerDataList.map((layer) => (
        <Grid2 key={layer.id}>
          <Card
            onClick={() => handleLayerClick(layer.id)}
            sx={{ cursor: 'pointer' }}
          >
            <CardMedia
              component="img"
              height="140"
              image={layer.imageUrl} // imageUrlを表示
              alt={layer.name}
            />
            <CardContent>
              <Typography variant="h6">{layer.name}</Typography>
              <Typography variant="body2" color="textSecondary">
                {`Size: ${layer.imageSize.width}x${layer.imageSize.height}`}
              </Typography>
            </CardContent>
          </Card>
        </Grid2>
      ))}
    </Grid2>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/LayerViewer.tsx ---
import { Box } from '@mui/material';
import { styled } from '@mui/system';
import React, { useRef } from 'react';
import { TransformComponent, TransformWrapper } from 'react-zoom-pan-pinch';
import { useLayerViewerViewModel } from '../../viewModels/LayerViewerViewModel';

const StyledCenterBox = styled(Box)({
  position: 'relative',
  flex: 1,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
});

const StyledSpherePinBox = styled(Box)({
  position: 'absolute',
  transform: 'translate(-50%, -50%)',
  cursor: 'pointer',
  width: '24px',
  height: '24px',
});

const StyledMainImg = styled('img')({
  width: '100%',
  height: '100%',
  objectFit: 'contain',
  cursor: 'grab',
});

const wrapperProps = {
  disabled: false,
  initialScale: 1,
  doubleClick: { mode: 'reset' as 'reset' }, //excluded: [], step: 0.7
  panning: { disabled: false, activationKeys: [], excluded: [] },
  pinch: { excluded: [], step: 5 },
  wheel: { activationKeys: [], excluded: [], smoothStep: 0.001, step: 0.2 },
};

export const LayerViewer: React.FC = () => {
  const { selectedLayer, sphereDataList, handleSphereClick } =
    useLayerViewerViewModel();
  const imageRef = useRef<HTMLImageElement>(null);

  if (!selectedLayer) {
    return <div>No layer selected</div>;
  }

  return (
    <StyledCenterBox>
      <TransformWrapper {...wrapperProps}>
        <TransformComponent>
          <StyledMainImg
            ref={imageRef}
            src={selectedLayer.imageUrl}
            alt={selectedLayer.name}
          />
          {/* Sphereのピンを配置 */}
          {sphereDataList
            .filter((sphere) => sphere.layerId === selectedLayer.id)
            .map((sphere) => (
              <StyledSpherePinBox
                key={sphere.id}
                title={sphere.name}
                onClick={() => handleSphereClick(sphere.id)}
                sx={{
                  top: `${(sphere.position.y / selectedLayer.imageSize.height) * 100}%`,
                  left: `${(sphere.position.x / selectedLayer.imageSize.width) * 100}%`,
                }}
              >
                <Box
                  component="img"
                  src="/images/marker-pano.png"
                  alt="Sphere Pin"
                  sx={{ width: '24px', height: '24px' }}
                />
              </StyledSpherePinBox>
            ))}
        </TransformComponent>
      </TransformWrapper>
    </StyledCenterBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/LocationViewer.tsx ---
import React from 'react';
import { MapContainer, TileLayer } from 'react-leaflet';
import styled from 'styled-components';
import { GeoLocation } from '../../types/map';
import { useLocationViewerViewModel } from '../../viewModels/LocationViewerViewModel';
import { LocationTooltip } from '../molecules/LocationTooltip';

const StyledMapContainer = styled(MapContainer)`
  width: 100%;
  height: 100%;
`;

// Base map tile:
const maps = {
  base: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
  google: 'https://mt1.google.com/vt/lyrs=r&x={x}&y={y}&z={z}',
};

export const LocationViewer: React.FC = () => {
  const { userGeoLocation, locationDataList, handlePopupClick } =
    useLocationViewerViewModel();

  const geoLocation: GeoLocation = userGeoLocation || {
    latitude: 35.68111,
    longitude: 139.76667,
  };

  return (
    <StyledMapContainer
      center={[geoLocation.latitude, geoLocation.longitude]}
      zoom={10}
    >
      <TileLayer
        url={maps.base}
        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      />

      {locationDataList.map((location) => (
        <LocationTooltip
          key={location.id}
          locationData={location}
          onClick={() => handlePopupClick(location.id)}
        />
      ))}
    </StyledMapContainer>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/MarkerViewer.tsx ---
import { Box, Typography } from '@mui/material';
import { styled } from '@mui/system';
import React from 'react';
import { TransformComponent, TransformWrapper } from 'react-zoom-pan-pinch';
import { useMarkerViewerViewModel } from '../../viewModels/MarkerViewerViewModel';

const StyledCenterBox = styled(Box)({
  position: 'relative',
  flex: 1,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  padding: 8,
});

const StyledH2Typography = styled(Typography)({
  component: 'h2',
  marginBottom: 2,
  color: 'white',
});

const StyledTypography = styled(Typography)({
  marginBottom: 2,
  color: 'white',
});

export const MarkerViewer: React.FC = () => {
  const { markerData } = useMarkerViewerViewModel();

  if (!markerData) {
    return null;
  }

  return (
    <>
      <StyledH2Typography id="marker-modal-title" variant="h6">
        {markerData.name}
      </StyledH2Typography>
      <StyledCenterBox>
        <TransformWrapper>
          <TransformComponent>
            <img
              src={markerData.imageUrl}
              alt={markerData.name}
              style={{
                // 画面中央
                display: 'block',
                marginLeft: 'auto',
                marginRight: 'auto',
                width: '100%',
              }}
            />
          </TransformComponent>
        </TransformWrapper>
      </StyledCenterBox>
      <StyledTypography id="marker-modal-description" variant="body1">
        {markerData.description}
      </StyledTypography>
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/SphereViewer.tsx ---
import { Box } from '@mui/material';
import { styled } from '@mui/system';
import '@photo-sphere-viewer/core/index.css';
import '@photo-sphere-viewer/map-plugin/index.css';
import '@photo-sphere-viewer/markers-plugin/index.css';
import React from 'react';
import { useSphereViewerViewModel } from '../../viewModels/SphereViewerViewModel';

interface SphereViewerProps {
  isDesktop: boolean;
  optionalContent?: React.ReactNode;
}
const StyledWholeBox = styled(Box)({
  position: 'relative',
  width: '100%',
  height: '100%',
  display: 'flex',
});

const ViewerBox = styled(Box)({
  position: 'relative',
  width: '100%',
  height: '100%',
});

export const SphereViewer: React.FC<SphereViewerProps> = ({
  isDesktop,
  optionalContent,
}) => {
  const { viewerRef } = useSphereViewerViewModel(isDesktop);

  const content = <ViewerBox ref={viewerRef}></ViewerBox>;

  return (
    <StyledWholeBox>
      {content}
      {optionalContent}
    </StyledWholeBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/TreeList.tsx ---
import { Box, Stack, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import { SimpleTreeView } from '@mui/x-tree-view/SimpleTreeView';
import React from 'react';
import { useTreeListViewModel } from '../../viewModels/TreeListViewModel';
import { TreeNode } from '../molecules/TreeNode';

const StyledSimpleTreeView = styled(SimpleTreeView)({
  '& .Mui-selected': {
    backgroundColor: 'transparent',
  },
});

export const TreeList: React.FC = () => {
  const {
    layerDataList,
    sphereDataList,
    markerDataList,
    selectedLayerId,
    selectedSphereId,
    selectedMarkerId,
    handleItemClick,
  } = useTreeListViewModel();

  // layerDataがない場合にnullを返す
  if (layerDataList.length === 0) {
    return <Typography>No layer data available</Typography>;
  }

  return (
    <Stack spacing={2}>
      <Box sx={{ minHeight: 352, minWidth: 300 }}>
        <StyledSimpleTreeView onItemClick={handleItemClick}>
          {layerDataList.map((layer) => (
            <TreeNode
              key={layer.id}
              id={layer.id}
              label={layer.name}
              isSelected={selectedLayerId === layer.id}
              onItemClick={handleItemClick}
            >
              {sphereDataList
                .filter((sphere) => sphere.layerId === layer.id)
                .map((sphere) => (
                  <TreeNode
                    key={sphere.id}
                    id={sphere.id}
                    label={sphere.name}
                    isSelected={selectedSphereId === sphere.id}
                    onItemClick={handleItemClick}
                  >
                    {markerDataList
                      .filter((marker) => marker.sphereId === sphere.id)
                      .map((marker) => (
                        <TreeNode
                          key={marker.id}
                          id={marker.id}
                          label={marker.name}
                          isSelected={selectedMarkerId === marker.id}
                          onItemClick={handleItemClick}
                        />
                      ))}
                  </TreeNode>
                ))}
            </TreeNode>
          ))}
        </StyledSimpleTreeView>
      </Box>
    </Stack>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/IndexPage.tsx ---
// src/components/pages/IndexPage.tsx
import { Box, Button, styled, Typography } from '@mui/material';
import React from 'react';
import { Link } from 'react-router-dom';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

export const IndexPage: React.FC = () => {
  return (
    <StyledBox>
      <Typography variant="h2" sx={{ marginBottom: 2 }}>
        Welcome to the App
      </Typography>

      {/* ログインページへのリンク */}
      <Link to="/login" style={{ textDecoration: 'none' }}>
        <Button variant="contained" color="secondary">
          ログインページへ
        </Button>
      </Link>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/LoginPage.tsx ---
// /workspaces/malaspherer-ui/frontend/src/components/pages/LoginPage.tsx
import { Box, Button, styled, TextField, Typography } from '@mui/material';
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { setIsAuthenticated } from '../../store/slices/statusSlice';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

const MailAndPassword = styled(TextField)({
  marginBottom: 2,
  width: '300px',
});

export const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const dispatch = useDispatch();

  const handleLogin = () => {
    if (!email || !password) {
      setError('メールアドレスとパスワードを入力してください。');
      return;
    }

    if (email.includes('@') && password.length > 5) {
      // ログイン成功 (トイモデルなので何もしない)
      setError('');
      dispatch(setIsAuthenticated(true));
      navigate('/map'); // ログイン成功後、viewページへ移動
    } else {
      setError('無効なメールアドレスまたはパスワードです。');
    }
  };

  return (
    <StyledBox>
      <Typography variant="h4" sx={{ marginBottom: 2 }}>
        ログイン
      </Typography>
      <MailAndPassword
        label="メールアドレス"
        variant="outlined"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <MailAndPassword
        label="パスワード"
        type="password"
        variant="outlined"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      {error && (
        <Typography color="error" sx={{ marginBottom: 2 }}>
          {error}
        </Typography>
      )}
      <Button variant="contained" color="primary" onClick={handleLogin}>
        ログイン
      </Button>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/MapPage.tsx ---
import React from 'react';
import { LocationViewer } from '../organisms/LocationViewer';
import { MapPageTemplate } from '../templates/MapPageTemplate';

export const MapPage: React.FC = () => {
  const content = <LocationViewer />;

  return <MapPageTemplate content={content} />;
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/NotFoundPage.tsx ---
import { Box, Button, Typography } from '@mui/material';
import React from 'react';
import { useNavigate } from 'react-router-dom';

export const NotFoundPage: React.FC = () => {
  const navigate = useNavigate();

  return (
    <Box
      display="flex"
      flexDirection="column"
      alignItems="center"
      justifyContent="center"
      height="100vh"
    >
      <Typography variant="h1">404</Typography>
      <Typography variant="h6" mb={2}>
        お探しのページは見つかりませんでした。
      </Typography>
      <Button onClick={() => navigate('/')} variant="contained" color="primary">
        ホームに戻る
      </Button>
    </Box>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/SettingPage.tsx ---
import { Box, Button, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { setIsAuthenticated } from '../../store/slices/statusSlice';
import { RootState } from '../../store/store';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

export const SettingPage: React.FC = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const isAuthenticated = useSelector(
    (state: RootState) => state.status.isAuthenticated
  );

  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/');
    }
  }, [isAuthenticated, navigate]);

  const handleLogout = () => {
    dispatch(setIsAuthenticated(false)); // ログアウト
  };

  return (
    <StyledBox>
      <Typography variant="h4" sx={{ marginBottom: 2 }}>
        設定ページ
      </Typography>
      <Button variant="contained" color="secondary" onClick={handleLogout}>
        ログアウト
      </Button>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/ViewPage.tsx ---
import React, { useEffect } from 'react';
import { useSelector } from 'react-redux';
import { useNavigate, useParams } from 'react-router-dom';
import { useMediaQuery } from '../../hooks/useMediaQuery';
import { RootState } from '../../store/store';
import { ViewPageTemplate } from '../templates/ViewPageTemplate';
import { NotFoundPage } from './NotFoundPage';

export const ViewPage: React.FC = () => {
  const { id } = useParams<{ id: string }>(); // URLパラメータからidを取得
  const isDesktop = useMediaQuery('pc');
  const navigate = useNavigate();
  const isAuthenticated = useSelector(
    (state: RootState) => state.status.isAuthenticated
  );
  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/');
    }
  }, [isAuthenticated, navigate]);

  if (!id) {
    return <NotFoundPage />;
  }

  return <ViewPageTemplate isDesktop={isDesktop} locationId={id} />;
};


--- /workspaces/lyssm-ui/frontend/src/components/templates/MapPageTemplate.tsx ---
// react
import React from 'react';
import styled from 'styled-components';
// components
import { Header } from '../organisms/HeaderBase';
// hooks
import { useFetchLocations } from '../../hooks/useFetchLocations';
import { useFetchUserGeoLocation } from '../../hooks/useFetchUserGeoLocation';

const Layout = styled('div')({
  display: 'flex',
  flexDirection: 'column',
  height: '100vh',
});

const Content = styled('main')({
  flex: 1,
  display: 'flex',
});

interface MapPageTemplateProps {
  content: React.ReactNode;
}

export const MapPageTemplate: React.FC<MapPageTemplateProps> = ({
  content,
}) => {
  useFetchUserGeoLocation();
  useFetchLocations();

  return (
    <Layout>
      <Header />
      <Content>{content}</Content>
    </Layout>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/templates/ViewPageTemplate.tsx ---
// react
import React from 'react';
// material-ui
import { styled } from '@mui/material';
// components
import { Sidebar } from '../molecules/Sidebar';
import { CompactHeader, Header } from '../organisms/HeaderBase';
// hooks
import { useFetchLayers } from '../../hooks/useFetchLayers';
import { useFetchMarkers } from '../../hooks/useFetchMarkers';
import { useFetchSpheres } from '../../hooks/useFetchSpheres';
// store
import { useViewPageTemplateViewModel } from '../../viewModels/ViewPageTemplateViewModel';
import { LayerTileGridButton } from '../molecules/LayerTileGridButton';
import { ModalNode } from '../molecules/ModalNode';
import { ToggleSidebarButton } from '../molecules/ToggleSidebarButton';
import { LayerTileGrid } from '../organisms/LayerTileGrid';
import { LayerViewer } from '../organisms/LayerViewer';
import { MarkerViewer } from '../organisms/MarkerViewer';
import { SphereViewer } from '../organisms/SphereViewer';
import { TreeList } from '../organisms/TreeList';

const Layout = styled('div')({
  display: 'flex',
  flexDirection: 'column',
  height: '100vh',
});

//header以外をカバーするコンポーネント
const WholeContent = styled('div')({
  display: 'flex',
  flex: 1,
});

const Content = styled('main')({
  flex: 1,
  display: 'flex',
  height: '100%',
  width: '100%',
});

const OptionalContent = styled('div')({
  position: 'absolute',
  top: 10,
  left: 10,
  zIndex: 1000,
});

interface ViewPageTemplateProps {
  isDesktop: boolean;
  locationId: string;
}

export const ViewPageTemplate: React.FC<ViewPageTemplateProps> = ({
  isDesktop,
  locationId,
}) => {
  const {
    isSidebarOpen,
    activeModal,
    selectedSphereId,
    closeModal,
    handleToggleSidebar,
    clearSelection,
  } = useViewPageTemplateViewModel();

  // カスタムフックの使用
  useFetchLayers(); // 修正箇所
  useFetchSpheres(); // 修正箇所
  useFetchMarkers(); // 修正箇所
  console.log('selectedSphereId:', selectedSphereId);
  const optionalContent = isDesktop ? (
    <OptionalContent>
      <ToggleSidebarButton
        isSidebarOpen={isSidebarOpen}
        onToggle={handleToggleSidebar}
      />
      <LayerTileGridButton onClick={clearSelection} />
    </OptionalContent>
  ) : (
    <OptionalContent>
      <LayerTileGridButton onClick={clearSelection} />
    </OptionalContent>
  );
  const mainContent = selectedSphereId ? (
    <SphereViewer isDesktop={isDesktop} optionalContent={optionalContent} />
  ) : (
    <LayerTileGrid />
  );
  const content: React.ReactNode = isDesktop ? (
    // PCの場合
    <Layout>
      {/* ヘッダ */}
      <Header />
      <WholeContent>
        {/* サイドバー */}
        <Sidebar isOpen={isSidebarOpen} content={<TreeList />} />
        {/* メインコンテンツ */}
        <Content>{mainContent}</Content>
      </WholeContent>
    </Layout>
  ) : (
    <Layout>
      {/* ヘッダ */}
      <CompactHeader />
      <WholeContent>
        {/* メインコンテンツ */}
        <Content>{mainContent}</Content>
      </WholeContent>
    </Layout>
  );

  return (
    <>
      {content}
      {/* レイヤーモーダルを表示 */}
      <ModalNode
        open={activeModal === 'layer'}
        onClose={closeModal}
        content={<LayerViewer />}
      />
      {/* マーカーモーダルを表示 */}
      <ModalNode
        open={activeModal === 'marker'}
        onClose={closeModal}
        content={<MarkerViewer />}
      />
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useAnimationFrame.ts ---
import { useCallback, useEffect, useRef } from 'react';

export const useAnimationFrame = (isRunning: boolean, callback: () => void) => {
  const reqIdRef = useRef<number | null>(null);

  const loop = useCallback(() => {
    if (isRunning) {
      reqIdRef.current = requestAnimationFrame(loop);
      callback();
    }
  }, [isRunning, callback]);

  useEffect(() => {
    if (isRunning) {
      reqIdRef.current = requestAnimationFrame(loop);
    }
    return () => {
      if (reqIdRef.current !== null) {
        cancelAnimationFrame(reqIdRef.current);
      }
    };
  }, [loop]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchLayers.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import { setIsLoading } from '../store/slices/statusSlice';
import { selectLayerDataList } from '../store/slices/viewSlice';

export const useFetchLayers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchLayers = async () => {
      try {
        const data = await ApiService.fetchLayers();
        dispatch(selectLayerDataList(data));
      } catch (error) {
        console.error('Error fetching layers:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchLayers();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchLocations.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import { selectLocationDataList } from '../store/slices/mapSlice';
import { setIsLoading } from '../store/slices/statusSlice';
import { LocationData } from '../types/map';

export const useFetchLocations = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchLocations = async () => {
      try {
        const data: LocationData[] = await ApiService.fetchLocations();
        dispatch(selectLocationDataList(data));
      } catch (error) {
        console.error('Error fetching Locations:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchLocations();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchMarkers.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import { setIsLoading } from '../store/slices/statusSlice';
import { selectMarkerDataList } from '../store/slices/viewSlice';

export const useFetchMarkers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchMarkers = async () => {
      try {
        const data = await ApiService.fetchMarkers();
        dispatch(selectMarkerDataList(data));
      } catch (error) {
        console.error('Error fetching markers:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchMarkers();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchSignedUrl.ts ---
import { useEffect, useState } from 'react';
import { ApiService } from '../services/apiService'; // APIサービス

export const useFetchSignedUrl = (fileId: string) => {
  const [signedUrl, setSignedUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUrl = async () => {
      try {
        const url = await ApiService.getSignedUrl(fileId);
        setSignedUrl(url);
      } catch (err) {
        setError('署名付きURLの取得に失敗しました');
      } finally {
        setLoading(false);
      }
    };

    fetchUrl();
  }, [fileId]);

  return { signedUrl, loading, error };
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchSpheres.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import { setIsLoading } from '../store/slices/statusSlice';
import { selectSphereDataList } from '../store/slices/viewSlice';

export const useFetchSpheres = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchSpheres = async () => {
      try {
        const data = await ApiService.fetchSpheres();
        dispatch(selectSphereDataList(data));
      } catch (error) {
        console.error('Error fetching spheres:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchSpheres();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchUserGeoLocation.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { setUserGeoLocation } from '../store/slices/mapSlice';
import { setErrorMessage } from '../store/slices/statusSlice';

export const useFetchUserGeoLocation = () => {
  const dispatch = useDispatch();

  const fetchUserGeoLocation = () => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          dispatch(
            setUserGeoLocation({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
            })
          );
        },
        (error) => {
          dispatch(setErrorMessage('現在位置の取得に失敗しました'));
          console.error('Error retrieving location:', error);
        }
      );
    } else {
      dispatch(
        setErrorMessage('Geolocationがこのブラウザでサポートされていません')
      );
      console.error('Geolocation is not supported by this browser.');
    }
  };

  useEffect(() => {
    fetchUserGeoLocation();
  }, []);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useMediaQuery.ts ---
import { useMediaQuery as muiUseMediaQuery, useTheme } from '@mui/material';

// MUIのブレークポイントシステムに対応した定義
export const mediaQuery = {
  mobile: 'down', // スマートフォンサイズ
  tablet: 'between', // タブレットサイズ
  pc: 'up', // PCサイズ
};

// ブレークポイントに基づいてクエリを生成
export const useMediaQuery = (queryKey: keyof typeof mediaQuery) => {
  const theme = useTheme(); // MUIのテーマを取得
  let query: string;

  // 必要に応じて適切なクエリを作成
  switch (queryKey) {
    case 'mobile':
      query = theme.breakpoints.down('sm'); // スマートフォンサイズ（小さい画面）
      break;
    case 'tablet':
      query = theme.breakpoints.between('sm', 'md'); // タブレットサイズ
      break;
    case 'pc':
      query = theme.breakpoints.up('md'); // PCサイズ
      break;
    default:
      throw new Error(`Invalid queryKey: ${queryKey}`);
  }

  const matches = muiUseMediaQuery(query); // MUIのuseMediaQueryを使用

  return matches; // true/falseを返す
};


--- /workspaces/lyssm-ui/frontend/src/index.tsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';
import './index.css';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


--- /workspaces/lyssm-ui/frontend/src/models/SphereViewerModel.ts ---
import { Viewer } from '@photo-sphere-viewer/core';
import '@photo-sphere-viewer/core/index.css';
import { MapPlugin } from '@photo-sphere-viewer/map-plugin';
import '@photo-sphere-viewer/map-plugin/index.css';
import { MarkersPlugin } from '@photo-sphere-viewer/markers-plugin';
import '@photo-sphere-viewer/markers-plugin/index.css';
import { LayerData, MarkerData, SphereData } from '../types/map';
// 必要なユーティリティ関数をインポートまたは定義
import { animateToMarker } from '../utils/animationUtils';
import { sleep } from '../utils/sleepUtils';
import { getNearestSpheres, getSphereDataRelative } from '../utils/sphereUtils';

export class SphereViewerModel {
  viewerInstance: Viewer | null = null;
  mapPlugin: MapPlugin | null = null;
  markersPlugin: MarkersPlugin | null = null;

  initializeViewer(container: HTMLDivElement, isDesktop: boolean) {
    //
    this.viewerInstance = new Viewer({
      container: container,
      panorama: '',
      caption: '',
      loadingImg: '/images/load-37_256.gif',
      touchmoveTwoFingers: false,
      mousewheelCtrlKey: true,
      navbar: isDesktop ? 'zoom caption' : 'caption',
      plugins: [
        [MarkersPlugin, {}],
        [
          MapPlugin,
          {
            position: 'bottom left',
            rotation: '0deg',
            shape: 'square',
            size: isDesktop ? '300px' : '150px',
            static: true,
          },
        ],
      ],
    });

    this.mapPlugin = this.viewerInstance.getPlugin<MapPlugin>(MapPlugin);
    this.markersPlugin =
      this.viewerInstance.getPlugin<MarkersPlugin>(MarkersPlugin);

    // デスクトップでない場合は、マップを非表示にする
    if (!isDesktop) {
      this.mapPlugin?.close();
    }
  }

  updateMarkersAndMap(
    selectedSphere: SphereData,
    sphereDataList: SphereData[],
    markerDataList: MarkerData[],
    markerTooltipContents: { [key: string]: string }
  ) {
    if (!this.viewerInstance || !this.markersPlugin || !this.mapPlugin) return;

    // マーカーのクリア
    this.markersPlugin.clearMarkers();

    // 近隣のSphereを取得
    const filteredSpheres = getNearestSpheres(sphereDataList, selectedSphere);

    // Sphereのマーカーを追加
    filteredSpheres.forEach((sphere) => {
      const size = sphere.distance < 500 ? 40 : 20;
      const yaw = (sphere.orientation.yaw / 180) * Math.PI;
      const pitch = (sphere.orientation.pitch / 180) * Math.PI;
      this.markersPlugin?.addMarker({
        id: sphere.sphereData.id,
        position: { yaw, pitch },
        image: '/images/marker-pano.png',
        size: { width: size, height: size },
        anchor: 'bottom center',
        tooltip: sphere.sphereData.name,
      });
    });

    // Sphereに属するマーカーを追加
    const filteredMarkers = markerDataList.filter(
      (marker) => selectedSphere.id === marker.sphereId
    );
    filteredMarkers.forEach((marker) => {
      this.markersPlugin?.addMarker({
        id: marker.id,
        position: {
          yaw: (marker.orientation.yaw * Math.PI) / 180,
          pitch: (marker.orientation.pitch * Math.PI) / 180,
        },
        image: '/images/icons8-pic-50.png',
        size: { width: 40, height: 40 },
        anchor: 'bottom center',
        tooltip: {
          content: markerTooltipContents[marker.id],
          className: 'custom-tooltip',
          position: 'top',
          trigger: 'hover',
        },
      });
    });

    // マップの中心を更新
    this.mapPlugin?.setCenter({
      x: selectedSphere.position.x,
      y: selectedSphere.position.y,
    });
  }

  handleLayerChange(selectedLayer: LayerData, sphereDataList: SphereData[]) {
    if (!this.viewerInstance || !this.mapPlugin) return;

    this.mapPlugin.setImage(selectedLayer.imageUrl);
    this.mapPlugin.setHotspots(
      sphereDataList
        .filter((sphere) => sphere.layerId === selectedLayer.id)
        .map((sphere) => ({
          id: sphere.id,
          x: sphere.position.x,
          y: sphere.position.y,
          image: '/images/marker-pano.png',
          size: 20,
        }))
    );
  }

  async handleSphereChange(
    selectedSphere: SphereData,
    lastSelectedSphere: SphereData | null,
    layerChanged: boolean
  ) {
    if (!this.viewerInstance) return;

    if (!layerChanged && lastSelectedSphere) {
      // レイヤーが同じ場合、アニメーションで移動
      const spheraDataRelative = getSphereDataRelative(
        selectedSphere,
        lastSelectedSphere
      );
      animateToMarker(
        this.viewerInstance,
        spheraDataRelative.orientation.yaw,
        spheraDataRelative.orientation.pitch
      );
      await sleep(1000);
    }
    this.viewerInstance
      .setPanorama(selectedSphere.imageUrl, { caption: selectedSphere.name })
      .catch((error) => console.error('Error loading sphere:', error));
  }

  handleMarkerChange(selectedMarker: MarkerData) {
    if (!this.viewerInstance) return;

    // マーカーの位置にアニメーションで移動
    animateToMarker(
      this.viewerInstance,
      selectedMarker.orientation.yaw,
      selectedMarker.orientation.pitch
    );
  }
}


--- /workspaces/lyssm-ui/frontend/src/react-app-env.d.ts ---
/// <reference types="react-scripts" />


--- /workspaces/lyssm-ui/frontend/src/reportWebVitals.ts ---
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- /workspaces/lyssm-ui/frontend/src/routes/routes.tsx ---
import { IndexPage } from '../components/pages/IndexPage';
import { LoginPage } from '../components/pages/LoginPage';
import { MapPage } from '../components/pages/MapPage';
import { NotFoundPage } from '../components/pages/NotFoundPage';
import { SettingPage } from '../components/pages/SettingPage';
import { ViewPage } from '../components/pages/ViewPage';

export const routes = [
  { path: '/', element: <IndexPage /> },
  { path: '/login', element: <LoginPage /> },
  { path: '/map', element: <MapPage /> },
  { path: '/view/:id', element: <ViewPage /> },
  { path: '/setting', element: <SettingPage /> },
  // 404ページ
  { path: '*', element: <NotFoundPage /> },
];


--- /workspaces/lyssm-ui/frontend/src/services/apiClient.ts ---
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://localhost:8000/api', // APIのベースURL
  timeout: 5000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 共通のリクエスト・レスポンス処理を追加
apiClient.interceptors.request.use(
  (config) => {
    // 必要に応じてトークンなどのヘッダーを追加
    // config.headers.Authorization = `Bearer ${token}`;
    return config;
  },
  (error) => Promise.reject(error)
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // エラーハンドリング
    console.error('API Error:', error);
    return Promise.reject(error);
  }
);

export default apiClient;


--- /workspaces/lyssm-ui/frontend/src/services/apiService.ts ---
import { sleep } from '../utils/sleepUtils';
import {
  isLayerDataList,
  isLocationDataList,
  isMarkerDataList,
  isSphereDataList,
} from '../utils/typeGuardUtils';
// import apiClient from './apiClient';

// 3. データのキャッシュ戦略
// react-queryを利用してデータのキャッシュや状態管理を行います。これにより、データの再フェッチを最小限に抑えられます。

export const ApiService = {
  async fetchLocations() {
    // const response = await apiClient.get<LocationData[]>('/facilities');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch facilities');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'location01',
        geoLocation: { latitude: 35.6762, longitude: 139.66 },
        name: 'Location Name 01',
        description: 'Location Name 01です',
        iconType: 'house',
      },
      {
        id: 'location02',
        geoLocation: { latitude: 35.6762, longitude: 139.7 },
        name: 'Location Name 02',
        description: 'Location Name 02です',
        iconType: 'default',
      },
      {
        id: 'location03',
        geoLocation: { latitude: 35.6762, longitude: 139.8 },
        name: 'Location Name 03',
        description: 'Location Name 03です',
        iconType: 'default',
      },
    ];
    if (!isLocationDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  async fetchLayers() {
    // const response = await apiClient.get<LayerData[]>('/layers');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch layers');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'layer01',
        locationId: 'location01',
        name: 'Layer Name 01',
        imageUrl: '/images/layer_sample.PNG',
        imageSize: { width: 1224, height: 1065 },
        createdAt: '2021-01-01T00:00:00',
        updatedAt: '2021-01-02T00:00:00',
      },
      {
        id: 'layer02',
        locationId: 'location01',
        name: 'Layer Name 02',
        imageUrl: '/images/layer_sample.PNG',
        imageSize: { width: 1224, height: 1065 },
        createdAt: '2021-01-01T00:00:00',
        updatedAt: '2021-01-02T00:00:00',
      },
      {
        id: 'layer03',
        locationId: 'location02',
        name: 'Layer Name 03',
        imageUrl: '/images/layer_sample.PNG',
        imageSize: { width: 1224, height: 1065 },
        createdAt: '2021-01-01T00:00:00',
        updatedAt: '2021-01-02T00:00:00',
      },
    ];
    if (!isLayerDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  async fetchMarkers() {
    // const response = await apiClient.get<MarkerData[]>('/markers');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch markers');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'marker01',
        sphereId: 'sphere01',
        name: 'Marker Name 01',
        description: 'This is marker 01',
        orientation: { yaw: 0, pitch: 0 },
        imageUrl: '/images/image-800x600.png',
        thumbnailUrl: '/images/image-160x120.png',
        markerType: 'default',
        createdAt: '2022-01-01T00:00:00',
      },
      {
        id: 'marker02',
        sphereId: 'sphere01',
        name: 'Marker Name 02',
        description: 'This is marker 02',
        orientation: { yaw: 45, pitch: 10 },
        imageUrl: '/images/image-800x600.png',
        thumbnailUrl: '/images/image-160x120.png',
        markerType: 'default',
        createdAt: '2023-01-01T00:00:00',
      },
    ];
    if (!isMarkerDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  async fetchSpheres() {
    // const response = await apiClient.get<SphereData[]>('/spheres');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch spheres');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'sphere01',
        layerId: 'layer01',
        name: 'Sphere Name 01',
        imageUrl: '/images/sphere_sample_01.jpg',
        position: {
          x: 500,
          y: 500,
        },
        createdAt: '2021-02-01T00:00:00',
      },
      {
        id: 'sphere02',
        layerId: 'layer01',
        name: 'Sphere Name 02',
        imageUrl: '/images/sphere_sample_02.JPG',
        position: {
          x: 600,
          y: 500,
        },
        createdAt: '2021-03-01T00:00:00',
      },
      {
        id: 'sphere03',
        layerId: 'layer02',
        name: 'Sphere Name 03',
        imageUrl: '/images/sphere_sample_01.jpg',
        position: {
          x: 500,
          y: 500,
        },
        createdAt: '2021-04-01T00:00:00',
      },
    ];
    if (!isSphereDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  // async getSignedUrl(fileId: string) {
  //   const response = await apiClient.get(`/get-signed-url/${fileId}`);
  //   return response.data.url;
  // },
  async getSignedUrl(url: string) {
    return url;
  },
  // 他のAPI呼び出しもここに追加
};


--- /workspaces/lyssm-ui/frontend/src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- /workspaces/lyssm-ui/frontend/src/store/slices/mapSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { GeoLocation, LocationData } from '../../types/map';

interface ViewerState {
  userGeoLocation: GeoLocation | null; // ユーザーの位置情報
  locationDataList: LocationData[]; // マーカーデータリスト
}

const initialState: ViewerState = {
  userGeoLocation: null,
  locationDataList: [],
};

const mapSlice = createSlice({
  name: 'map',
  initialState,
  reducers: {
    setUserGeoLocation: (state, action: PayloadAction<GeoLocation | null>) => {
      state.userGeoLocation = action.payload;
    },
    selectLocationDataList: (state, action: PayloadAction<LocationData[]>) => {
      state.locationDataList = action.payload;
    },
  },
});

export const { setUserGeoLocation, selectLocationDataList } = mapSlice.actions;

export default mapSlice.reducer;


--- /workspaces/lyssm-ui/frontend/src/store/slices/statusSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';

interface StatusState {
  isAuthenticated: boolean; // 認証済みかどうか
  isLoading: boolean; // ローディング中かどうか
  isSidebarOpen: boolean; // サイドバーが開いているかどうか
  activeModal: 'layer' | 'marker' | null; // アクティブなモーダル
  notificationMessage: string | null; // 通知メッセージ
  errorMessage: string | null; // エラーメッセージ
}

const initialState: StatusState = {
  isAuthenticated: false,
  isLoading: false,
  isSidebarOpen: true,
  activeModal: null,
  notificationMessage: null,
  errorMessage: null,
};

const statusSlice = createSlice({
  name: 'status',
  initialState,
  reducers: {
    setIsAuthenticated: (state, action: PayloadAction<boolean>) => {
      state.isAuthenticated = action.payload;
    },
    setIsLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload;
    },
    toggleSidebar: (state) => {
      state.isSidebarOpen = !state.isSidebarOpen;
    },
    setActiveModal: (
      state,
      action: PayloadAction<'layer' | 'marker' | null>
    ) => {
      state.activeModal = action.payload;
    },
    setNotificationMessage: (state, action: PayloadAction<string | null>) => {
      state.notificationMessage = action.payload;
    },
    setErrorMessage: (state, action: PayloadAction<string | null>) => {
      state.errorMessage = action.payload;
    },
  },
});

export const {
  setIsAuthenticated,
  setIsLoading,
  toggleSidebar,
  setActiveModal,
  setNotificationMessage,
  setErrorMessage,
} = statusSlice.actions;

export default statusSlice.reducer;


--- /workspaces/lyssm-ui/frontend/src/store/slices/viewSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { LayerData, MarkerData, SphereData } from '../../types/map';

interface ViewerState {
  selectedLayerId: string | null; // 選択中のレイヤーID
  lastSelectedSphereId: string | null; // 直前に選択したSphereID
  selectedSphereId: string | null; // 選択中のSphereID
  selectedMarkerId: string | null; // 選択中のマーカーID
  layerDataList: LayerData[]; // レイヤーデータリスト
  sphereDataList: SphereData[]; // Sphereデータリスト
  markerDataList: MarkerData[]; // マーカーデータリスト
}

const initialState: ViewerState = {
  selectedLayerId: null,
  lastSelectedSphereId: null,
  selectedSphereId: null,
  selectedMarkerId: null,
  layerDataList: [],
  sphereDataList: [],
  markerDataList: [],
};

const viewerSlice = createSlice({
  name: 'viewer',
  initialState,
  reducers: {
    selectLayerId: (state, action: PayloadAction<string | null>) => {
      state.selectedLayerId = action.payload;
    },
    selectLastSphereId: (state, action: PayloadAction<string | null>) => {
      state.lastSelectedSphereId = action.payload;
    },
    selectSphereId: (state, action: PayloadAction<string | null>) => {
      state.selectedSphereId = action.payload;
    },
    selectMarkerId: (state, action: PayloadAction<string | null>) => {
      state.selectedMarkerId = action.payload;
    },
    selectLayerDataList: (state, action: PayloadAction<LayerData[]>) => {
      state.layerDataList = action.payload;
    },
    selectSphereDataList: (state, action: PayloadAction<SphereData[]>) => {
      state.sphereDataList = action.payload;
    },
    selectMarkerDataList: (state, action: PayloadAction<MarkerData[]>) => {
      state.markerDataList = action.payload;
    },
  },
});

export const {
  selectLayerId,
  selectLastSphereId,
  selectSphereId,
  selectMarkerId,
  selectLayerDataList,
  selectSphereDataList,
  selectMarkerDataList,
} = viewerSlice.actions;

export default viewerSlice.reducer;


--- /workspaces/lyssm-ui/frontend/src/store/store.ts ---
import { configureStore } from '@reduxjs/toolkit';
import mapReducer from './slices/mapSlice';
import statusReducer from './slices/statusSlice';
import viewerReducer from './slices/viewSlice';

const store = configureStore({
  reducer: {
    status: statusReducer,
    viewer: viewerReducer,
    map: mapReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

export default store;


--- /workspaces/lyssm-ui/frontend/src/types/map.d.ts ---
export interface GeoLocation {
  latitude: number;
  longitude: number;
  altitude?: number;
}

export interface Position {
  x: number;
  y: number;
}

export interface Orientation {
  yaw: number;
  pitch: number;
}

export interface ImageSize {
  width: number;
  height: number;
}

export interface LocationData {
  id: string;
  geoLocation: GeoLocation;
  name: string;
  description: string;
  iconType: 'default' | 'house';
  websiteUrl?: string; // Optional
}

export interface LayerData {
  id: string;
  locationId: string;
  name: string;
  imageUrl: string;
  imageSize: ImageSize;
  createdAt: string;
  updatedAt: string;
}

export interface SphereData {
  id: string;
  name: string;
  imageUrl: string;
  position: Position;
  createdAt: string;
  layerId?: string; // Optional layerIdがない場合はレイヤー上でなく、地図上に表示
  geoLocation?: GeoLocation; // Optional
}

export interface MarkerData {
  id: string;
  sphereId: string;
  name: string;
  description: string;
  orientation: Orientation;
  imageUrl: string;
  thumbnailUrl: string;
  markerType: string;
  createdAt: string;
}


--- /workspaces/lyssm-ui/frontend/src/utils/animationUtils.ts ---
// src/utils/animationUtils.ts
import { Viewer } from '@photo-sphere-viewer/core';

export const animateToMarker = (
  viewer: Viewer,
  yaw: number, // Yaw in degrees
  pitch: number, // Pitch in degrees
  speed: number = 500
) => {
  viewer.animate({
    yaw: (yaw * Math.PI) / 180,
    pitch: (pitch * Math.PI) / 180,
    speed: speed,
  });
};


--- /workspaces/lyssm-ui/frontend/src/utils/mapUtils.ts ---
import { default as L } from 'leaflet';
import 'leaflet/dist/leaflet.css';

// カスタムアイコンの定義
const icons: { [key: string]: L.Icon } = {
  //   default: Leaflet.Marker.prototype.options.icon,
  default: new L.Icon({
    iconUrl: '/images/marker-icon.png',
    popupAnchor: [12, 0],
  }),
  house: new L.Icon({
    iconUrl: '/images/ie-icon.png',
    iconSize: [32, 32],
    iconAnchor: [16, -16],
    popupAnchor: [0, 16],
  }),
  // 他のアイコンもここに追加できます
};

export const getLocationIcon = (iconType: string): L.Icon => {
  return icons[iconType] || icons.default;
};


--- /workspaces/lyssm-ui/frontend/src/utils/sleepUtils.ts ---
export const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};


--- /workspaces/lyssm-ui/frontend/src/utils/sphereUtils.ts ---
import { Orientation, SphereData } from '../types/map';

interface SphereDataRelative {
  sphereData: SphereData;
  distance: number;
  orientation: Orientation;
}

export const getSphereDataRelative = (
  targetSphere: SphereData,
  selectedSphere: SphereData
): SphereDataRelative => {
  const dx = targetSphere.position.x - selectedSphere.position.x;
  const dy = targetSphere.position.y - selectedSphere.position.y;
  const distance = Math.sqrt(dx ** 2 + dy ** 2);
  if (distance === 0) {
    return {
      sphereData: targetSphere,
      distance,
      orientation: { yaw: 0, pitch: 0 },
    };
  }
  const orientation: Orientation = {
    yaw: Math.atan2(dx, -dy) * (180 / Math.PI),
    pitch: 0.0 * (180 / Math.PI),
  };
  return { sphereData: targetSphere, distance, orientation };
};

export const getNearestSpheres = (
  spheres: SphereData[],
  selectedSphere: SphereData,
  radius: number = 1000
): SphereDataRelative[] => {
  // selectedSphereからの距離と方向を計算
  const targetSpheres: SphereData[] = spheres.filter(
    (sphereData) =>
      sphereData.layerId === selectedSphere.layerId &&
      sphereData !== selectedSphere
  );
  const sphereDataRelatives: SphereDataRelative[] = targetSpheres.map(
    (sphereData) => {
      return getSphereDataRelative(sphereData, selectedSphere);
    }
  );

  // distanceに応じてソート
  sphereDataRelatives.sort((a, b) => a.distance - b.distance);

  // radius以内のSphereを取得
  var nearestSpheres: SphereDataRelative[] = [];
  for (const sphereDataRelative of sphereDataRelatives) {
    if (
      sphereDataRelative.distance <= radius &&
      sphereDataRelative.sphereData !== selectedSphere &&
      sphereDataRelative.sphereData.layerId === selectedSphere.layerId
    ) {
      nearestSpheres.push(sphereDataRelative);
    }
  }

  // yaw, pitchで5度以内のsphereは除外
  var filteredSpheres: SphereDataRelative[] = [];
  for (const sphereDataRelative of nearestSpheres) {
    var isNear = false;
    for (const filteredSphere of filteredSpheres) {
      const dy =
        sphereDataRelative.orientation.yaw - filteredSphere.orientation.yaw;
      const dp =
        sphereDataRelative.orientation.pitch - filteredSphere.orientation.pitch;
      const criterionDegrees = 5;
      if (dy < criterionDegrees || dp < criterionDegrees) {
        isNear = true;
        break;
      }
    }
    if (!isNear) {
      filteredSpheres.push(sphereDataRelative);
    }
  }

  return filteredSpheres;
};


--- /workspaces/lyssm-ui/frontend/src/utils/typeGuardUtils.ts ---
// src/utils/typeGuards.ts
import {
  GeoLocation,
  ImageSize,
  LayerData,
  LocationData,
  MarkerData,
  Orientation,
  Position,
  SphereData,
} from '../types/map';

function isGeoLocation(data: any): data is GeoLocation {
  return (
    typeof data === 'object' &&
    'latitude' in data &&
    'longitude' in data &&
    typeof data.latitude === 'number' &&
    typeof data.longitude === 'number'
  );
}

function isPosition(data: any): data is Position {
  return (
    typeof data === 'object' &&
    'x' in data &&
    'y' in data &&
    typeof data.x === 'number' &&
    typeof data.y === 'number'
  );
}

function isOrientation(data: any): data is Orientation {
  return (
    typeof data === 'object' &&
    'yaw' in data &&
    'pitch' in data &&
    typeof data.yaw === 'number' &&
    typeof data.pitch === 'number'
  );
}

function isImageSize(data: any): data is ImageSize {
  return (
    typeof data === 'object' &&
    'width' in data &&
    'height' in data &&
    typeof data.width === 'number' &&
    typeof data.height === 'number'
  );
}

function isLocationData(data: any): data is LocationData {
  return (
    typeof data === 'object' &&
    'id' in data &&
    'geoLocation' in data &&
    'name' in data &&
    'description' in data &&
    isGeoLocation(data.geoLocation)
  );
}

export function isLocationDataList(data: any): data is LocationData[] {
  return Array.isArray(data) && data.every(isLocationData);
}

function isLayerData(data: any): data is LayerData {
  return (
    typeof data === 'object' &&
    'id' in data &&
    'locationId' in data &&
    'name' in data &&
    'imageUrl' in data &&
    'imageSize' in data &&
    'createdAt' in data &&
    'updatedAt' in data &&
    isImageSize(data.imageSize)
  );
}

export function isLayerDataList(data: any): data is LayerData[] {
  return Array.isArray(data) && data.every(isLayerData);
}

function isSphereData(data: any): data is SphereData {
  return (
    typeof data === 'object' &&
    'id' in data &&
    'name' in data &&
    'imageUrl' in data &&
    'position' in data &&
    'createdAt' in data &&
    isPosition(data.position)
  );
}

export function isSphereDataList(data: any): data is SphereData[] {
  return Array.isArray(data) && data.every(isSphereData);
}

function isMarkerData(data: any): data is MarkerData {
  return (
    typeof data === 'object' &&
    'id' in data &&
    'sphereId' in data &&
    'name' in data &&
    'description' in data &&
    'orientation' in data &&
    'imageUrl' in data &&
    'thumbnailUrl' in data &&
    'markerType' in data &&
    'createdAt' in data &&
    isOrientation(data.orientation)
  );
}

export function isMarkerDataList(data: any): data is MarkerData[] {
  return Array.isArray(data) && data.every(isMarkerData);
}


--- /workspaces/lyssm-ui/frontend/src/utils/viewUtils.ts ---
import { Position, Viewer } from '@photo-sphere-viewer/core';
import { Orientation } from '../types/map';

export const getOrientation = (viewer: Viewer | null) => {
  if (!viewer) return { yaw: 0, pitch: 0 };
  const position: Position = viewer.getPosition();
  if (!position) return { yaw: 0, pitch: 0 };
  // 小数点以下第1位までで四捨五入
  const orientation: Orientation = {
    yaw: Math.round(((position.yaw * 180) / Math.PI) * 10) / 10,
    pitch: Math.round(((position.pitch * 180) / Math.PI) * 10) / 10,
  };
  return orientation;
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/LayerTileGridViewModel.ts ---
import { useDispatch, useSelector } from 'react-redux';
import { setActiveModal } from '../store/slices/statusSlice';
import { selectLayerId } from '../store/slices/viewSlice';
import { RootState } from '../store/store';

export const useLayerTileGridViewModel = () => {
  const dispatch = useDispatch();
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );

  const handleLayerClick = (layerId: string) => {
    console.log(`Layer clicked: ${layerId}`);
    // レイヤークリック時の処理をここに記述
    dispatch(selectLayerId(layerId));
    dispatch(setActiveModal('layer' as 'layer'));
  };

  return {
    layerDataList,
    handleLayerClick,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/LayerViewerViewModel.ts ---
import { useDispatch, useSelector } from 'react-redux';
import { setActiveModal } from '../store/slices/statusSlice';
import { selectSphereId } from '../store/slices/viewSlice';
import { RootState } from '../store/store';

export const useLayerViewerViewModel = () => {
  const dispatch = useDispatch();
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );

  const selectedLayer = layerDataList.find(
    (layer) => layer.id === selectedLayerId
  );

  // Sphereのピンをクリックしたときの処理
  const handleSphereClick = (sphereId: string) => {
    dispatch(selectSphereId(sphereId));
    dispatch(setActiveModal(null));
  };

  return {
    selectedLayer,
    sphereDataList,
    handleSphereClick,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/LocationViewerViewModel.ts ---
import { useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { RootState } from '../store/store';

export const useLocationViewerViewModel = () => {
  const navigate = useNavigate();
  const userGeoLocation = useSelector(
    (state: RootState) => state.map.userGeoLocation
  );
  const locationDataList = useSelector(
    (state: RootState) => state.map.locationDataList
  );

  const handlePopupClick = (locationId: string) => {
    navigate(`/view/${locationId}`);
  };

  return {
    userGeoLocation,
    locationDataList,
    handlePopupClick,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/MarkerViewerViewModel.ts ---
import { useSelector } from 'react-redux';
import { RootState } from '../store/store';

export const useMarkerViewerViewModel = () => {
  const selectedMarkerId = useSelector(
    (state: RootState) => state.viewer.selectedMarkerId
  );
  const markerDataList = useSelector(
    (state: RootState) => state.viewer.markerDataList
  );
  const markerData = markerDataList.find(
    (marker) => marker.id === selectedMarkerId
  );

  return {
    markerData,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/SphereViewerViewModel.tsx ---
// react
import { useEffect, useMemo, useRef } from 'react';
import ReactDOMServer from 'react-dom/server';
import { useDispatch, useSelector } from 'react-redux';
// global state
import { setActiveModal } from '../store/slices/statusSlice';
import {
  selectLastSphereId,
  selectLayerId,
  selectMarkerId,
  selectSphereId,
} from '../store/slices/viewSlice';
import { RootState } from '../store/store';
// model
import { SphereViewerModel } from '../models/SphereViewerModel';
// utils
import { CustomTooltip } from '../components/molecules/CustomTooltip';

export const useSphereViewerViewModel = (isDesktop: boolean) => {
  const dispatch = useDispatch();
  const viewerRef = useRef<HTMLDivElement | null>(null);
  const sphereViewerModelRef = useRef<SphereViewerModel | null>(null);

  // 現在のyawとpitchを保持
  // const [currentOrientation, setCurrentOrientation] = useState<Orientation>({
  //   yaw: 0.0,
  //   pitch: 0.0,
  // });
  // updateOrientationはuseCallbackでラップし、無駄な再生成を避ける
  // const updateOrientation = useCallback(() => {
  //   if (sphereViewerModelRef.current) {
  //     const orientation = getOrientation(
  //       sphereViewerModelRef.current.viewerInstance
  //     );
  //     setCurrentOrientation((prev) => {
  //       // 違いが大きい時だけ更新して、無駄な再レンダリングを防ぐ
  //       if (
  //         Math.abs(orientation.yaw - prev.yaw) > 0.1 ||
  //         Math.abs(orientation.pitch - prev.pitch) > 0.1
  //       ) {
  //         return orientation;
  //       }
  //       return prev;
  //     });
  //   }
  // }, [sphereViewerModelRef]);
  // デスクトップ時のみアニメーションを有効化
  // useAnimationFrame(isDesktop, updateOrientation);

  const {
    selectedLayerId,
    lastSelectedSphereId,
    selectedSphereId,
    selectedMarkerId,
    layerDataList,
    sphereDataList,
    markerDataList,
  } = useSelector((state: RootState) => state.viewer);

  // ツールチップの内容をView側で作成
  const markerTooltipContents = useMemo(() => {
    return markerDataList.reduce(
      (contents, marker) => {
        const tooltipContent = ReactDOMServer.renderToStaticMarkup(
          <CustomTooltip markerData={marker} key={marker.id} />
        );
        contents[marker.id] = tooltipContent;
        return contents;
      },
      {} as { [key: string]: string }
    );
  }, [markerDataList]);

  // Viewerの初期化
  useEffect(() => {
    if (!viewerRef.current) return;

    sphereViewerModelRef.current = new SphereViewerModel();
    sphereViewerModelRef.current.initializeViewer(viewerRef.current, isDesktop);

    // ビューアのイベントリスナーを設定
    const viewerInstance = sphereViewerModelRef.current.viewerInstance;
    const mapPlugin = sphereViewerModelRef.current.mapPlugin;
    const markersPlugin = sphereViewerModelRef.current.markersPlugin;

    // Sphere上にあるマーカークリック時の処理
    markersPlugin?.addEventListener('select-marker', ({ marker }) => {
      // Sphere上にあるマーカーがSphereかどうか判定
      const selectedSphere = sphereDataList.find(
        (sphere) => sphere.id === marker.id
      );
      if (selectedSphere) {
        dispatch(selectSphereId(marker.id));
        dispatch(selectMarkerId(null));
        return;
      }
      // Sphere上にあるマーカーがMarkerかどうか判定
      const selectedMarker = markerDataList.find(
        (_marker) => _marker.id === marker.id
      );
      if (selectedMarker) {
        dispatch(selectMarkerId(marker.id));
        dispatch(setActiveModal('marker' as 'marker'));
      }
    });

    // ホットスポットクリック時の処理
    mapPlugin?.addEventListener('select-hotspot', ({ hotspotId }) => {
      dispatch(selectSphereId(hotspotId));
    });

    return () => {
      viewerInstance?.destroy();
      sphereViewerModelRef.current = null;
    };
  }, [markerDataList, sphereDataList, layerDataList, isDesktop]);

  // Layerの変更時
  // やること: handleLayerChangeを呼び出す
  // 監視対象: selectedLayerId, layerDataList
  useEffect(() => {
    // console.log('selectedLayerId', selectedLayerId);
    if (!selectedLayerId || !sphereViewerModelRef.current) return;

    const selectedLayer = layerDataList.find(
      (layer) => layer.id === selectedLayerId
    );
    if (!selectedLayer) return;

    sphereViewerModelRef.current.handleLayerChange(
      selectedLayer,
      sphereDataList
    );
  }, [selectedLayerId]); //, layerDataList, sphereDataList

  // Sphereの変更時
  // やること: handleSphereChangeを呼び出す、マーカーとマップの更新、lastSelectedSphereIdを更新
  // 監視対象: selectedSphereId, sphereDataList, markerDataList, layerDataList
  useEffect(() => {
    // console.log('selectedSphereId', selectedSphereId);
    if (!selectedSphereId || !sphereViewerModelRef.current) return;

    const selectedSphere = sphereDataList.find(
      (sphere) => sphere.id === selectedSphereId
    );
    if (!selectedSphere) return;

    const lastSelectedSphere = sphereDataList.find(
      (sphere) => sphere.id === lastSelectedSphereId
    );

    const layerChanged = selectedSphere.layerId !== lastSelectedSphere?.layerId;

    if (layerChanged && selectedSphere.layerId) {
      dispatch(selectLayerId(selectedSphere.layerId));
    }
    sphereViewerModelRef.current.handleSphereChange(
      selectedSphere,
      lastSelectedSphere || null,
      layerChanged
    );

    dispatch(selectLastSphereId(selectedSphere.id));

    // マーカーとマップの更新
    sphereViewerModelRef.current.updateMarkersAndMap(
      selectedSphere,
      sphereDataList,
      markerDataList,
      markerTooltipContents
    );
  }, [selectedSphereId]); //, markerDataList, sphereDataList, layerDataList

  // Markerの変更時
  // やること: handleMarkerChangeを呼び出す
  // 監視対象: selectedMarkerId, markerDataList
  useEffect(() => {
    // console.log('selectedMarkerId', selectedMarkerId);
    if (!selectedMarkerId || !sphereViewerModelRef.current) return;

    const selectedMarker = markerDataList.find(
      (marker) => marker.id === selectedMarkerId
    );
    if (!selectedMarker) return;

    sphereViewerModelRef.current.handleMarkerChange(selectedMarker);
  }, [selectedMarkerId]); //, markerDataList

  return {
    viewerRef,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/TreeListViewModel.ts ---
import { useDispatch, useSelector } from 'react-redux';
import {
  selectLayerId,
  selectMarkerId,
  selectSphereId,
} from '../store/slices/viewSlice';
import { RootState } from '../store/store';

export const useTreeListViewModel = () => {
  const dispatch = useDispatch();
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const markerDataList = useSelector(
    (state: RootState) => state.viewer.markerDataList
  );
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const selectedSphereId = useSelector(
    (state: RootState) => state.viewer.selectedSphereId
  );
  const selectedMarkerId = useSelector(
    (state: RootState) => state.viewer.selectedMarkerId
  );

  const handleItemClick = (
    event: React.SyntheticEvent<Element, Event>,
    itemId: string
  ) => {
    const selectedLayer = layerDataList.find((layer) => layer.id === itemId);
    if (selectedLayer) {
      // dispatch(selectLayerId(itemId));
      // dispatch(selectSphereId(null));
      // dispatch(selectMarkerId(null));
      return;
    }

    const selectedSphere = sphereDataList.find(
      (sphere) => sphere.id === itemId
    );
    if (selectedSphere && selectedSphere.layerId) {
      dispatch(selectLayerId(selectedSphere.layerId));
      dispatch(selectSphereId(itemId));
      dispatch(selectMarkerId(null));
      return;
    }

    const selectedMarker = markerDataList.find(
      (marker) => marker.id === itemId
    );
    if (selectedMarker) {
      const sphereOfMarker = sphereDataList.find(
        (sphere) => sphere.id === selectedMarker.sphereId
      );
      if (sphereOfMarker && sphereOfMarker.layerId) {
        dispatch(selectLayerId(sphereOfMarker.layerId));
        dispatch(selectSphereId(selectedMarker.sphereId));
        dispatch(selectMarkerId(itemId));
        return;
      }
    }
  };

  return {
    layerDataList,
    sphereDataList,
    markerDataList,
    selectedLayerId,
    selectedSphereId,
    selectedMarkerId,
    handleItemClick,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/ViewPageTemplateViewModel.ts ---
import { useDispatch, useSelector } from 'react-redux';
import { setActiveModal, toggleSidebar } from '../store/slices/statusSlice';
import {
  selectLayerId,
  selectMarkerId,
  selectSphereId,
} from '../store/slices/viewSlice';
import { RootState } from '../store/store';

export const useViewPageTemplateViewModel = () => {
  const dispatch = useDispatch();
  const isSidebarOpen = useSelector(
    (state: RootState) => state.status.isSidebarOpen
  );
  const activeModal = useSelector(
    (state: RootState) => state.status.activeModal
  );
  const selectedSphereId = useSelector(
    (state: RootState) => state.viewer.selectedSphereId
  );
  const closeModal = () => {
    dispatch(setActiveModal(null));
  };
  const handleToggleSidebar = () => {
    dispatch(toggleSidebar());
  };
  const clearSelection = () => {
    dispatch(selectLayerId(null));
    dispatch(selectSphereId(null));
    dispatch(selectMarkerId(null));
  };

  return {
    isSidebarOpen,
    activeModal,
    selectedSphereId,
    closeModal,
    handleToggleSidebar,
    clearSelection,
  };
};

