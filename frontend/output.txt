--- /workspaces/lyssm-ui/frontend/src/App.test.tsx ---
import React from 'react';
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


--- /workspaces/lyssm-ui/frontend/src/App.tsx ---
import React from 'react';
import { Provider } from 'react-redux'; // Redux Provider のインポート
import { Route, BrowserRouter as Router, Routes } from 'react-router-dom';
import { routes } from './routes/routes';
import store from './store/store'; // Redux ストアのインポート

const App: React.FC = () => {
  return (
    // Redux の Provider でアプリ全体をラップ
    <Provider store={store}>
      <Router>
        <Routes>
          {routes.map((route, index) => (
            <Route key={index} path={route.path} element={route.element} />
          ))}
        </Routes>
      </Router>
    </Provider>
  );
};

export default App;


--- /workspaces/lyssm-ui/frontend/src/components/atoms/ErrorSnackbar.tsx ---
import { Alert, Snackbar } from '@mui/material';
import React from 'react';

// TODO: このコンポーネントは、エラーメッセージを表示するSnackbarです。
// TODO: あとで実装します。

interface ErrorSnackbarProps {
  open: boolean;
  message: string;
  onClose: () => void;
}

export const ErrorSnackbar: React.FC<ErrorSnackbarProps> = ({
  open,
  message,
  onClose,
}) => {
  return (
    <Snackbar open={open} autoHideDuration={6000} onClose={onClose}>
      <Alert onClose={onClose} severity="error">
        {message}
      </Alert>
    </Snackbar>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/atoms/Label.tsx ---
// src/components/atoms/Label.tsx
import { Typography } from '@mui/material';
import React from 'react';

interface LabelProps {
  text: string;
  color?: string;
}

export const Label: React.FC<LabelProps> = ({ text, color = 'black' }) => (
  <Typography style={{ color }}>{text}</Typography>
);


--- /workspaces/lyssm-ui/frontend/src/components/molecules/CustomTooltip.tsx ---
import React from 'react';
import styled from 'styled-components';
import { MarkerData } from '../../types/map';

// スタイルの定義
// CustomTooltipはあとで静的なHTMLとして描画するため、styled-componentsを使ってスタイルを定義
// MUIは使わない
const StyledWrapper = styled.div`
  max-width: none;
  padding: 0;
  box-shadow: 0 0 0 2px white;
`;

const StyledImage = styled.img`
  width: 100%;
  border-radius: 4px 4px 0 0;
  padding: 30;
`;

const StyledContent = styled.article`
  margin: 1rem;
  text-align: justify;
`;

const StyledTitle = styled.h2`
  margin: 0;
`;

const StyledText = styled.p`
  margin: 0;
`;

interface CustomTooltipProps {
  markerData: MarkerData;
}

export const CustomTooltip: React.FC<CustomTooltipProps> = ({ markerData }) => {
  return (
    <>
      {/* Tooltip内容 */}
      <StyledWrapper className="custom-tooltip">
        <StyledImage src={markerData.thumbnailUrl} alt={markerData.name} />
        <StyledContent>
          <StyledTitle>{markerData.name}</StyledTitle>
          <StyledText>{markerData.description}</StyledText>
        </StyledContent>
      </StyledWrapper>

      {/* モーダルで詳細を表示 */}
      {/* <Modal open={open} onClose={handleClose}>
        <Box
          sx={{
            position: 'absolute',
            top: '50%',
            left: '50%',
            transform: 'translate(-50%, -50%)',
            width: '80%',
            bgcolor: 'background.paper',
            boxShadow: 24,
            p: 4,
          }}
        >
          <Typography variant="h4" component="h2" gutterBottom>
            {markerData.name}
          </Typography>
          <img
            src={markerData.thumbnailUrl}
            alt={markerData.name}
            style={{ width: '100%', borderRadius: '8px' }}
          />
          <Typography variant="body1" mt={2}>
            {markerData.description}
          </Typography>
          <Button
            onClick={handleClose}
            variant="contained"
            sx={{ marginTop: '20px' }}
          >
            閉じる
          </Button>
        </Box>
      </Modal> */}
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/SettingMenu.tsx ---
import { MoreVert } from '@mui/icons-material';
import { IconButton } from '@mui/material';
import React from 'react';
import { useNavigate } from 'react-router-dom';

export const MoreMenu: React.FC = () => {
  const navigate = useNavigate();

  const handleSettingsClick = () => {
    navigate('/setting');
  };

  return (
    <IconButton
      edge="start"
      color="inherit"
      aria-label="menu"
      onClick={handleSettingsClick}
    >
      <MoreVert />
    </IconButton>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/ToggleSidebarButton.tsx ---
import styled from '@emotion/styled';
import {
  KeyboardDoubleArrowLeft,
  KeyboardDoubleArrowRight,
} from '@mui/icons-material';
import { IconButton } from '@mui/material';
import React from 'react';

interface ToggleSidebarButtonProps {
  isSidebarOpen: boolean;
  onToggle: () => void;
}

const StyledIconButton = styled(IconButton)({
  position: 'absolute',
  top: 10,
  left: 10,
  zIndex: 1000,
  backgroundColor: 'rgba(255, 255, 255, 0.5)',
});

export const ToggleSidebarButton: React.FC<ToggleSidebarButtonProps> = ({
  isSidebarOpen,
  onToggle,
}) => {
  return (
    <StyledIconButton onClick={onToggle}>
      {isSidebarOpen ? (
        <KeyboardDoubleArrowLeft />
      ) : (
        <KeyboardDoubleArrowRight />
      )}
    </StyledIconButton>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/TreeNode.tsx ---
import { styled } from '@mui/styles';
import { TreeItem } from '@mui/x-tree-view/TreeItem';
import React from 'react';

interface TreeNodeProps {
  id: string;
  label: string;
  children?: React.ReactNode;
  onItemClick: (event: React.SyntheticEvent, itemId: string) => void;
  isSelected?: boolean;
}

const StyledTreeItem = styled(TreeItem)(({ color }) => ({
  color: color,
}));

export const TreeNode: React.FC<TreeNodeProps> = ({
  id,
  label,
  children,
  onItemClick,
  isSelected,
}) => {
  return (
    <StyledTreeItem
      key={id}
      itemId={id}
      label={label}
      onClick={(event) => onItemClick(event, id)}
      color={isSelected ? 'rgba(0, 0, 0, 0.1)' : 'transparent'}
    >
      {children}
    </StyledTreeItem>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/molecules/YawPitchDisplay.tsx ---
import { Box, styled } from '@mui/material';
import React from 'react';
import { Label } from '../atoms/Label';

interface YawPitchDisplayProps {
  yaw: number;
  pitch: number;
}

const StyledBox = styled(Box)({
  position: 'absolute',
  bottom: 45,
  right: 10,
  backgroundColor: 'rgba(0, 0, 0, 0.5)',
  padding: '5px 10px',
  borderRadius: '5px',
});

export const YawPitchDisplay: React.FC<YawPitchDisplayProps> = ({
  yaw,
  pitch,
}) => {
  return (
    <StyledBox>
      <Label text={`Yaw: ${yaw.toFixed(2)}°`} color="white" />
      <Label text={`Pitch: ${pitch.toFixed(2)}°`} color="white" />
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/HeaderBase.tsx ---
import { AppBar, Toolbar, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import React from 'react';
import { MoreMenu } from '../molecules/SettingMenu';
import { LayerDrawer } from './LayerDrawer';

interface HeaderBaseProps {
  isDesktop: boolean;
}

const HeaderBase: React.FC<HeaderBaseProps> = ({ isDesktop }) => {
  const StyledTypography = styled(Typography)({
    flexGrow: 1,
  });

  return (
    <AppBar position="static">
      <Toolbar>
        <StyledTypography variant="h6">View Page</StyledTypography>
        {!isDesktop && <LayerDrawer />}
        <MoreMenu />
      </Toolbar>
    </AppBar>
  );
};

export const Header: React.FC = () => <HeaderBase isDesktop={true} />;
export const CompactHeader: React.FC = () => <HeaderBase isDesktop={false} />;


--- /workspaces/lyssm-ui/frontend/src/components/organisms/LayerDrawer.tsx ---
import { Layers } from '@mui/icons-material';
import CloseIcon from '@mui/icons-material/Close';
import { Box, Drawer, IconButton } from '@mui/material';
import { styled } from '@mui/styles';
import React, { useState } from 'react';
import { TreeList } from './TreeList'; // TreeListのインポート

const DrawerBox = styled(Box)({
  width: 300,
  padding: 16,
  paddingTop: 48, // 閉じるボタン分のスペースを確保
  position: 'relative',
});

const CloseButtonBox = styled(Box)({
  position: 'absolute',
  top: 8, // ボタンを右上に固定
  right: 8,
});

export const LayerDrawer: React.FC = () => {
  const [isOpen, setIsOpen] = useState(false);

  const toggleDrawer = (open: boolean) => () => {
    setIsOpen(open);
  };

  return (
    <>
      {/* メニューを開くボタン */}
      <IconButton onClick={toggleDrawer(true)} color="inherit">
        <Layers />
      </IconButton>

      {/* 右からスライドするメニュー */}
      <Drawer anchor="right" open={isOpen} onClose={toggleDrawer(false)}>
        <DrawerBox role="presentation">
          {/* 閉じるボタン */}
          <CloseButtonBox>
            <IconButton onClick={toggleDrawer(false)}>
              <CloseIcon />
            </IconButton>
          </CloseButtonBox>
          {/* TreeListを表示 */}
          <TreeList />
        </DrawerBox>
      </Drawer>
    </>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/LayerViewerBase.tsx ---
// /workspaces/malaspherer-ui/frontend/src/components/organisms/LayerViewer.tsx
import { Box } from '@mui/material';
import { styled } from '@mui/system';
import React, { useEffect, useRef, useState } from 'react';
import { TransformComponent, TransformWrapper } from 'react-zoom-pan-pinch';
import { useLayerViewerViewModel } from '../../viewModels/LayerViewerViewModel';
import { ToggleSidebarButton } from '../molecules/ToggleSidebarButton';

interface LayerViewerBaseProps {
  isDesktop: boolean;
}

const StyledWholeBox = styled(Box)({
  position: 'relative',
  width: '100%',
  height: '100%',
  display: 'flex',
});

const StyledCenterBox = styled(Box)({
  position: 'relative',
  flex: 1,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
});

const StyledSpherePinBox = styled(Box)({
  position: 'absolute',
  transform: 'translate(-50%, -50%)',
  cursor: 'pointer',
  width: '24px',
  height: '24px',
});

const StyledMainImg = styled('img')({
  width: '100%',
  height: '100%',
});

const LayerViewerBase: React.FC<LayerViewerBaseProps> = ({ isDesktop }) => {
  const {
    selectedLayer,
    sphereDataList,
    handleSphereClick,
    isSidebarOpen,
    handleToggleSidebar,
  } = useLayerViewerViewModel();
  const imageRef = useRef<HTMLImageElement>(null);
  const [imageSize, setImageSize] = useState({ width: 1, height: 1 });

  useEffect(() => {
    if (imageRef.current) {
      const { naturalWidth, naturalHeight } = imageRef.current;
      setImageSize({ width: naturalWidth, height: naturalHeight });
    }
  }, [selectedLayer]);

  if (!selectedLayer) {
    return <div>No layer selected</div>;
  }

  return (
    <StyledWholeBox>
      {/*
      トグルボタンを左上に配置
      画面が小さい場合はサイドバーを用いないので、表示しない
      */}
      {isDesktop && (
        <ToggleSidebarButton
          isSidebarOpen={isSidebarOpen}
          onToggle={handleToggleSidebar}
        />
      )}
      <StyledCenterBox>
        <TransformWrapper>
          <TransformComponent>
            <StyledMainImg
              ref={imageRef}
              src={selectedLayer.imageUrl}
              alt={selectedLayer.name}
            />
            {/* Sphereのピンを配置 */}
            {sphereDataList
              .filter((sphere) => sphere.layerId === selectedLayer.id)
              .map((sphere) => (
                <StyledSpherePinBox
                  key={sphere.id}
                  title={sphere.name}
                  onClick={() => handleSphereClick(sphere.id)}
                  sx={{
                    top: `${(sphere.position.y / imageSize.height) * 100}%`,
                    left: `${(sphere.position.x / imageSize.width) * 100}%`,
                  }}
                >
                  <Box
                    component="img"
                    src="/images/marker-pano.png"
                    alt="Sphere Pin"
                    sx={{ width: '24px', height: '24px' }}
                  />
                </StyledSpherePinBox>
              ))}
          </TransformComponent>
        </TransformWrapper>
      </StyledCenterBox>
    </StyledWholeBox>
  );
};

// export const CompactPanoramaViewer = () => (
//   <PanoramaViewerBase isDesktop={false} />
// );
// export const PanoramaViewer = () => <PanoramaViewerBase isDesktop={true} />;

export const LayerViewer: React.FC = () => <LayerViewerBase isDesktop={true} />;
export const CompactLayerViewer: React.FC = () => (
  <LayerViewerBase isDesktop={false} />
);


--- /workspaces/lyssm-ui/frontend/src/components/organisms/MarkerModal.tsx ---
import CloseIcon from '@mui/icons-material/Close';
import { Box, IconButton, Modal, Typography } from '@mui/material';
import { styled } from '@mui/system';
import React from 'react';
import { TransformComponent, TransformWrapper } from 'react-zoom-pan-pinch';
import { MarkerData } from '../../types/map';
import { useMarkerModalViewModel } from '../../viewModels/MarkerModalViewModel';

interface MarkerModalProps {
  open: boolean;
  onClose: () => void;
  markerData: MarkerData | null;
}

const StyledModalBox = styled(Box)({
  position: 'absolute',
  top: '50%',
  left: '50%',
  transform: 'translate(-50%, -50%)',
  width: '85%',
  maxWidth: '800px',
  bgcolor: 'rgba(0, 0, 0, 0.2)',
  p: 1,
  maxHeight: '90vh',
  overflowY: 'auto',
  paddingTop: 36, // 閉じるボタン分のスペースを確保
});

const StyledCenterBox = styled(Box)({
  position: 'relative',
  flex: 1,
  display: 'flex',
  justifyContent: 'center',
  alignItems: 'center',
  padding: 8,
});

const StyledIconButton = styled(IconButton)({
  position: 'absolute',
  top: 0,
  right: 0,
  color: 'white',
});

const StyledH2Typography = styled(Typography)({
  component: 'h2',
  marginBottom: 2,
  color: 'white',
});

const StyledTypography = styled(Typography)({
  marginBottom: 2,
  color: 'white',
});

export const MarkerModal: React.FC<MarkerModalProps> = ({
  open,
  onClose,
  markerData,
}) => {
  useMarkerModalViewModel(onClose);

  if (!markerData) {
    return null;
  }

  return (
    <Modal
      open={open}
      onClose={onClose}
      aria-labelledby="marker-modal-title"
      aria-describedby="marker-modal-description"
    >
      <StyledModalBox>
        <StyledIconButton onClick={onClose}>
          <CloseIcon />
        </StyledIconButton>
        <StyledH2Typography id="marker-modal-title" variant="h6">
          {markerData.name}
        </StyledH2Typography>
        <StyledCenterBox>
          <TransformWrapper>
            <TransformComponent>
              <img
                src={markerData.imageUrl}
                alt={markerData.name}
                style={{
                  // 画面中央
                  display: 'block',
                  marginLeft: 'auto',
                  marginRight: 'auto',
                  width: '100%',
                }}
              />
            </TransformComponent>
          </TransformWrapper>
        </StyledCenterBox>
        <StyledTypography id="marker-modal-description" variant="body1">
          {markerData.description}
        </StyledTypography>
      </StyledModalBox>
    </Modal>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/PanoramaViewerBase.tsx ---
import { Box } from '@mui/material';
import { styled } from '@mui/system';
import '@photo-sphere-viewer/core/index.css';
import '@photo-sphere-viewer/map-plugin/index.css';
import '@photo-sphere-viewer/markers-plugin/index.css';
import React from 'react';
import { usePanoramaViewerViewModel } from '../../viewModels/PanoramaViewerViewModel';
import { ToggleSidebarButton } from '../molecules/ToggleSidebarButton';
import { YawPitchDisplay } from '../molecules/YawPitchDisplay';
import { MarkerModal } from './MarkerModal';

interface PanoramaViewerBaseProps {
  isDesktop: boolean;
}
const StyledWholeBox = styled(Box)({
  position: 'relative',
  width: '100%',
  height: '100%',
  display: 'flex',
});

const StyledFlexBox = styled(Box)({
  flexGrow: 1,
});

const ViewerBox = styled(Box)({
  position: 'relative',
  width: '100%',
  height: '100%',
});

export const PanoramaViewerBase: React.FC<PanoramaViewerBaseProps> = ({
  isDesktop,
}) => {
  const {
    viewerRef,
    currentOrientation,
    isSidebarOpen,
    isMarkerModalOpen,
    handleToggleSidebar,
    selectedMarkerData,
    handleCloseMarkerModal,
  } = usePanoramaViewerViewModel(isDesktop);

  return (
    <StyledWholeBox>
      <StyledFlexBox>
        {/* ビューア本体 */}
        <ViewerBox ref={viewerRef}></ViewerBox>

        {/*
        yawとpitchを右下に表示
        画面が小さい場合は省略
        */}
        {isDesktop && (
          <YawPitchDisplay
            yaw={currentOrientation.yaw}
            pitch={currentOrientation.pitch}
          />
        )}

        {/*
        トグルボタンを左上に配置
        画面が小さい場合はサイドバーを用いないので、表示しない
        */}
        {isDesktop && (
          <ToggleSidebarButton
            isSidebarOpen={isSidebarOpen}
            onToggle={handleToggleSidebar}
          />
        )}
      </StyledFlexBox>
      {/* selectedMarkerDataがTruethyならMarkerModalを表示 */}
      {!!selectedMarkerData && (
        <MarkerModal
          open={isMarkerModalOpen}
          onClose={handleCloseMarkerModal}
          markerData={selectedMarkerData}
        />
      )}
    </StyledWholeBox>
  );
};

export const CompactPanoramaViewer = () => (
  <PanoramaViewerBase isDesktop={false} />
);
export const PanoramaViewer = () => <PanoramaViewerBase isDesktop={true} />;


--- /workspaces/lyssm-ui/frontend/src/components/organisms/Sidebar.tsx ---
// import styled from 'styled-components';
import { styled } from '@mui/system';
import { TreeList } from './TreeList';

const SidebarWrapper = styled('div')({
  display: 'flex',
  flexDirection: 'row',
  position: 'relative',
});

const SidebarContainer = styled('div')<{ isOpen: boolean }>(({ isOpen }) => ({
  overflowY: 'auto',
  backgroundColor: '#fff',
  transition: 'width 0.3s ease, padding 0.3s ease',
  boxShadow: isOpen ? '2px 0 5px rgba(0, 0, 0, 0.1)' : 'none',
  width: isOpen ? 'var(--sidebar-width, 300px)' : '0',
  padding: isOpen ? '10px' : '0',
  '@media (max-width: 768px)': {
    width: isOpen ? '100%' : '0',
  },
}));

interface SidebarProps {
  isOpen: boolean;
}

export const Sidebar: React.FC<SidebarProps> = ({ isOpen }) => {
  return (
    <SidebarWrapper>
      <SidebarContainer isOpen={isOpen} aria-hidden={!isOpen} role="region">
        <TreeList />
      </SidebarContainer>
    </SidebarWrapper>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/organisms/TreeList.tsx ---
import { Box, Stack, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import { SimpleTreeView } from '@mui/x-tree-view/SimpleTreeView';
import React from 'react';
import { useSidebarTreeViewModel } from '../../viewModels/SidebarTreeViewModel';
import { useTreeListViewModel } from '../../viewModels/TreeListViewModel';
import { TreeNode } from '../molecules/TreeNode';

const StyledSimpleTreeView = styled(SimpleTreeView)({
  '& .Mui-selected': {
    backgroundColor: 'transparent',
  },
  bgcolor: 'transparent',
});

export const TreeList: React.FC = () => {
  const { handleItemClick } = useSidebarTreeViewModel();
  const {
    layerDataList,
    sphereDataList,
    markerDataList,
    selectedLayerId,
    selectedSphereId,
    selectedMarkerId,
  } = useTreeListViewModel();

  // layerDataがない場合にnullを返す
  if (layerDataList.length === 0) {
    return <Typography>No layer data available</Typography>;
  }

  return (
    <Stack spacing={2}>
      <Box sx={{ minHeight: 352, minWidth: 300 }}>
        <StyledSimpleTreeView onItemClick={handleItemClick}>
          {layerDataList.map((layer) => (
            <TreeNode
              key={layer.id}
              id={layer.id}
              label={layer.name}
              isSelected={selectedLayerId === layer.id}
              onItemClick={handleItemClick}
            >
              {sphereDataList
                .filter((sphere) => sphere.layerId === layer.id)
                .map((sphere) => (
                  <TreeNode
                    key={sphere.id}
                    id={sphere.id}
                    label={sphere.name}
                    isSelected={selectedSphereId === sphere.id}
                    onItemClick={handleItemClick}
                  >
                    {markerDataList
                      .filter((marker) => marker.sphereId === sphere.id)
                      .map((marker) => (
                        <TreeNode
                          key={marker.id}
                          id={marker.id}
                          label={marker.name}
                          isSelected={selectedMarkerId === marker.id}
                          onItemClick={handleItemClick}
                        />
                      ))}
                  </TreeNode>
                ))}
            </TreeNode>
          ))}
        </StyledSimpleTreeView>
      </Box>
    </Stack>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/IndexPage.tsx ---
// src/components/pages/IndexPage.tsx
import { Box, Button, styled, Typography } from '@mui/material';
import React from 'react';
import { Link } from 'react-router-dom';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

export const IndexPage: React.FC = () => {
  return (
    <StyledBox>
      <Typography variant="h2" sx={{ marginBottom: 2 }}>
        Welcome to the App
      </Typography>

      {/* ログインページへのリンク */}
      <Link to="/login" style={{ textDecoration: 'none' }}>
        <Button variant="contained" color="secondary">
          ログインページへ
        </Button>
      </Link>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/LoginPage.tsx ---
// /workspaces/malaspherer-ui/frontend/src/components/pages/LoginPage.tsx
import { Box, Button, styled, TextField, Typography } from '@mui/material';
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { setIsAuthenticated } from '../../store/slices/viewerSlice';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

const MailAndPassword = styled(TextField)({
  marginBottom: 2,
  width: '300px',
});

export const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const dispatch = useDispatch();

  const handleLogin = () => {
    if (!email || !password) {
      setError('メールアドレスとパスワードを入力してください。');
      return;
    }

    if (email.includes('@') && password.length > 5) {
      // ログイン成功 (トイモデルなので何もしない)
      setError('');
      dispatch(setIsAuthenticated(true));
      navigate('/view'); // ログイン成功後、viewページへ移動
    } else {
      setError('無効なメールアドレスまたはパスワードです。');
    }
  };

  return (
    <StyledBox>
      <Typography variant="h4" sx={{ marginBottom: 2 }}>
        ログイン
      </Typography>
      <MailAndPassword
        label="メールアドレス"
        variant="outlined"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <MailAndPassword
        label="パスワード"
        type="password"
        variant="outlined"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
      />
      {error && (
        <Typography color="error" sx={{ marginBottom: 2 }}>
          {error}
        </Typography>
      )}
      <Button variant="contained" color="primary" onClick={handleLogin}>
        ログイン
      </Button>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/MapPage.tsx ---
import React from 'react'

export const MapPage: React.FC = () => {
  return <div>Map Page</div>
}


--- /workspaces/lyssm-ui/frontend/src/components/pages/SettingPage.tsx ---
import { Box, Button, Typography } from '@mui/material';
import { styled } from '@mui/styles';
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { setIsAuthenticated } from '../../store/slices/viewerSlice';
import { RootState } from '../../store/store';

const StyledBox = styled(Box)({
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  justifyContent: 'center',
  height: '100vh',
});

export const SettingPage: React.FC = () => {
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const isAuthenticated = useSelector(
    (state: RootState) => state.viewer.isAuthenticated
  );

  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login');
    }
  }, [isAuthenticated, navigate]);

  const handleLogout = () => {
    dispatch(setIsAuthenticated(false)); // ログアウト
  };

  return (
    <StyledBox>
      <Typography variant="h4" sx={{ marginBottom: 2 }}>
        設定ページ
      </Typography>
      <Button variant="contained" color="secondary" onClick={handleLogout}>
        ログアウト
      </Button>
    </StyledBox>
  );
};


--- /workspaces/lyssm-ui/frontend/src/components/pages/ViewPage.tsx ---
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { useMediaQuery } from '../../hooks/useMediaQuery';
import { selectLayerId } from '../../store/slices/viewerSlice';
import { RootState } from '../../store/store';
import { CompactLayerViewer, LayerViewer } from '../organisms/LayerViewerBase';
import {
  CompactPanoramaViewer,
  PanoramaViewer,
} from '../organisms/PanoramaViewerBase';
import { ViewPageTemplate } from '../templates/ViewPageTemplate';

export const ViewPage: React.FC = () => {
  // const { id } = useParams<{ id: string }>(); // URLパラメータからidを取得
  const dispatch = useDispatch();
  const navigate = useNavigate();
  const isAuthenticated = useSelector(
    (state: RootState) => state.viewer.isAuthenticated
  );
  const selectedSphereId = useSelector(
    (state: RootState) => state.viewer.selectedSphereId
  );
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const isMoblie = useMediaQuery('mobile');

  useEffect(() => {
    if (!isAuthenticated) {
      navigate('/login');
    }
  }, [isAuthenticated, navigate]);

  useEffect(() => {
    if (layerDataList.length > 0 && !selectedLayerId) {
      dispatch(selectLayerId(layerDataList[0].id));
    }
  }, [dispatch, layerDataList, selectedLayerId]);

  const content = selectedSphereId ? (
    isMoblie ? (
      <CompactPanoramaViewer />
    ) : (
      <PanoramaViewer />
    )
  ) : isMoblie ? (
    <CompactLayerViewer />
  ) : (
    <LayerViewer />
  );

  return <ViewPageTemplate content={content} />;
};


--- /workspaces/lyssm-ui/frontend/src/components/templates/ViewPageTemplate.tsx ---
import { styled } from '@mui/material';
import React from 'react';
import { useSelector } from 'react-redux';
import { useFetchLayers } from '../../hooks/useFetchLayers';
import { useFetchMarkers } from '../../hooks/useFetchMarkers';
import { useFetchSpheres } from '../../hooks/useFetchSpheres';
import { useMediaQuery } from '../../hooks/useMediaQuery';
import { RootState } from '../../store/store';
import { CompactHeader, Header } from '../organisms/HeaderBase';
import { Sidebar } from '../organisms/Sidebar';

const Layout = styled('div')({
  display: 'flex',
  flexDirection: 'column',
  height: '100vh',
});

const WholeContent = styled('div')({
  display: 'flex',
  height: '100%',
});

const Content = styled('main')({
  flex: 1,
  display: 'flex',
});

interface ViewPageTemplateProps {
  content: React.ReactNode;
}

export const ViewPageTemplate: React.FC<ViewPageTemplateProps> = ({
  content,
}) => {
  const isMobile = useMediaQuery('mobile');
  const isSidebarOpen = useSelector(
    (state: RootState) => state.viewer.isSidebarOpen
  );

  // カスタムフックの使用
  useFetchLayers(); // 修正箇所
  useFetchSpheres(); // 修正箇所
  useFetchMarkers(); // 修正箇所

  return isMobile ? (
    // スマホの場合
    <Layout>
      <CompactHeader />
      <WholeContent>
        <Content>{content}</Content>
      </WholeContent>
    </Layout>
  ) : (
    // PCの場合
    <Layout>
      <Header />
      <WholeContent>
        {/* サイドバー */}
        {<Sidebar isOpen={isSidebarOpen} />}
        {/* メインコンテンツ */}
        <Content>{content}</Content>
      </WholeContent>
    </Layout>
  );
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchLayers.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import { selectLayerDataList, setIsLoading } from '../store/slices/viewerSlice';

export const useFetchLayers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchLayers = async () => {
      try {
        const data = await ApiService.fetchLayers();
        dispatch(selectLayerDataList(data));
      } catch (error) {
        console.error('Error fetching layers:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchLayers();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchMarkers.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import {
  selectMarkerDataList,
  setIsLoading,
} from '../store/slices/viewerSlice';

export const useFetchMarkers = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchMarkers = async () => {
      try {
        const data = await ApiService.fetchMarkers();
        dispatch(selectMarkerDataList(data));
      } catch (error) {
        console.error('Error fetching markers:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchMarkers();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchSignedUrl.ts ---
import { useEffect, useState } from 'react';
import { ApiService } from '../services/apiService'; // APIサービス

export const useFetchSignedUrl = (fileId: string) => {
  const [signedUrl, setSignedUrl] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchUrl = async () => {
      try {
        const url = await ApiService.getSignedUrl(fileId);
        setSignedUrl(url);
      } catch (err) {
        setError('署名付きURLの取得に失敗しました');
      } finally {
        setLoading(false);
      }
    };

    fetchUrl();
  }, [fileId]);

  return { signedUrl, loading, error };
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useFetchSpheres.ts ---
import { useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { ApiService } from '../services/apiService';
import {
  selectSphereDataList,
  setIsLoading,
} from '../store/slices/viewerSlice';

export const useFetchSpheres = () => {
  const dispatch = useDispatch();

  useEffect(() => {
    dispatch(setIsLoading(true));
    const fetchSpheres = async () => {
      try {
        const data = await ApiService.fetchSpheres();
        dispatch(selectSphereDataList(data));
      } catch (error) {
        console.error('Error fetching spheres:', error);
      } finally {
        dispatch(setIsLoading(false));
      }
    };
    fetchSpheres();
  }, [dispatch]);
};


--- /workspaces/lyssm-ui/frontend/src/hooks/useMediaQuery.ts ---
import { useMediaQuery as muiUseMediaQuery, useTheme } from '@mui/material';

// MUIのブレークポイントシステムに対応した定義
export const mediaQuery = {
  mobile: 'down', // スマートフォンサイズ
  tablet: 'between', // タブレットサイズ
  pc: 'up', // PCサイズ
};

// ブレークポイントに基づいてクエリを生成
export const useMediaQuery = (queryKey: keyof typeof mediaQuery) => {
  const theme = useTheme(); // MUIのテーマを取得
  let query: string;

  // 必要に応じて適切なクエリを作成
  switch (queryKey) {
    case 'mobile':
      query = theme.breakpoints.down('sm'); // スマートフォンサイズ（小さい画面）
      break;
    case 'tablet':
      query = theme.breakpoints.between('sm', 'md'); // タブレットサイズ
      break;
    case 'pc':
      query = theme.breakpoints.up('md'); // PCサイズ
      break;
    default:
      throw new Error(`Invalid queryKey: ${queryKey}`);
  }

  const matches = muiUseMediaQuery(query); // MUIのuseMediaQueryを使用

  return matches; // true/falseを返す
};


--- /workspaces/lyssm-ui/frontend/src/index.tsx ---
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'
import reportWebVitals from './reportWebVitals'

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement)
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals()


--- /workspaces/lyssm-ui/frontend/src/models/PanoramaViewerModel.ts ---
import { Viewer } from '@photo-sphere-viewer/core';
import '@photo-sphere-viewer/core/index.css';
import { MapPlugin } from '@photo-sphere-viewer/map-plugin';
import '@photo-sphere-viewer/map-plugin/index.css';
import { MarkersPlugin } from '@photo-sphere-viewer/markers-plugin';
import '@photo-sphere-viewer/markers-plugin/index.css';
import { LayerData, MarkerData, SphereData } from '../types/map';
// 必要なユーティリティ関数をインポートまたは定義
import { animateToMarker } from '../utils/animationUtils';
import { sleep } from '../utils/sleepUtils';
import { getNearestSpheres, getSphereDataRelative } from '../utils/sphereUtils';

export class PanoramaViewerModel {
  viewerInstance: Viewer | null = null;
  mapPlugin: MapPlugin | null = null;
  markersPlugin: MarkersPlugin | null = null;

  initializeViewer(container: HTMLDivElement, isDesktop: boolean) {
    this.viewerInstance = new Viewer({
      container: container,
      panorama: '',
      caption: '',
      loadingImg: '/images/load-37_256.gif',
      touchmoveTwoFingers: false,
      mousewheelCtrlKey: true,
      navbar: isDesktop ? 'zoom caption' : 'caption',
      plugins: [
        [MarkersPlugin, {}],
        [
          MapPlugin,
          {
            position: 'bottom left',
            rotation: '0deg',
            shape: 'square',
            size: isDesktop ? '300px' : '150px',
            static: true,
          },
        ],
      ],
    });

    this.mapPlugin = this.viewerInstance.getPlugin<MapPlugin>(MapPlugin);
    this.markersPlugin =
      this.viewerInstance.getPlugin<MarkersPlugin>(MarkersPlugin);

    // デスクトップでない場合は、マップを非表示にする
    if (!isDesktop) {
      this.mapPlugin?.close();
    }
  }

  updateMarkersAndMap(
    selectedSphere: SphereData,
    sphereDataList: SphereData[],
    markerDataList: MarkerData[],
    markerTooltipContents: { [key: string]: string }
  ) {
    if (!this.viewerInstance || !this.markersPlugin || !this.mapPlugin) return;

    // マーカーのクリア
    this.markersPlugin.clearMarkers();

    // 近隣のSphereを取得
    const filteredSpheres = getNearestSpheres(sphereDataList, selectedSphere);

    // Sphereのマーカーを追加
    filteredSpheres.forEach((sphere) => {
      const size = sphere.distance < 500 ? 40 : 20;
      const yaw = (sphere.orientation.yaw / 180) * Math.PI;
      const pitch = (sphere.orientation.pitch / 180) * Math.PI;
      this.markersPlugin?.addMarker({
        id: sphere.sphereData.id,
        position: { yaw, pitch },
        image: '/images/marker-pano.png',
        size: { width: size, height: size },
        anchor: 'bottom center',
        tooltip: sphere.sphereData.name,
      });
    });

    // Sphereに属するマーカーを追加
    const filteredMarkers = markerDataList.filter(
      (marker) => selectedSphere.id === marker.sphereId
    );
    filteredMarkers.forEach((marker) => {
      this.markersPlugin?.addMarker({
        id: marker.id,
        position: {
          yaw: (marker.orientation.yaw * Math.PI) / 180,
          pitch: (marker.orientation.pitch * Math.PI) / 180,
        },
        image: '/images/icons8-pic-50.png',
        size: { width: 40, height: 40 },
        anchor: 'bottom center',
        tooltip: {
          content: markerTooltipContents[marker.id],
          className: 'custom-tooltip',
          position: 'top',
          trigger: 'hover',
        },
      });
    });

    // マップの中心を更新
    this.mapPlugin?.setCenter({
      x: selectedSphere.position.x,
      y: selectedSphere.position.y,
    });
  }

  handleLayerChange(selectedLayer: LayerData, sphereDataList: SphereData[]) {
    if (!this.viewerInstance || !this.mapPlugin) return;

    this.mapPlugin.setImage(selectedLayer.imageUrl);
    this.mapPlugin.setHotspots(
      sphereDataList
        .filter((sphere) => sphere.layerId === selectedLayer.id)
        .map((sphere) => ({
          id: sphere.id,
          x: sphere.position.x,
          y: sphere.position.y,
          image: '/images/marker-pano.png',
          size: 20,
        }))
    );
  }

  async handleSphereChange(
    selectedSphere: SphereData,
    lastSelectedSphere: SphereData | null,
    layerChanged: boolean
  ) {
    if (!this.viewerInstance) return;

    if (!layerChanged && lastSelectedSphere) {
      // レイヤーが同じ場合、アニメーションで移動
      const spheraDataRelative = getSphereDataRelative(
        selectedSphere,
        lastSelectedSphere
      );
      animateToMarker(
        this.viewerInstance,
        spheraDataRelative.orientation.yaw,
        spheraDataRelative.orientation.pitch
      );
      await sleep(1000);
    }
    this.viewerInstance
      .setPanorama(selectedSphere.imageUrl, { caption: selectedSphere.name })
      .catch((error) => console.error('Error loading panorama:', error));
  }

  handleMarkerChange(selectedMarker: MarkerData) {
    if (!this.viewerInstance) return;

    // マーカーの位置にアニメーションで移動
    animateToMarker(
      this.viewerInstance,
      selectedMarker.orientation.yaw,
      selectedMarker.orientation.pitch
    );
  }
}


--- /workspaces/lyssm-ui/frontend/src/react-app-env.d.ts ---
/// <reference types="react-scripts" />


--- /workspaces/lyssm-ui/frontend/src/reportWebVitals.ts ---
import { ReportHandler } from 'web-vitals';

const reportWebVitals = (onPerfEntry?: ReportHandler) => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


--- /workspaces/lyssm-ui/frontend/src/routes/routes.tsx ---
import { IndexPage } from '../components/pages/IndexPage';
import { LoginPage } from '../components/pages/LoginPage';
import { MapPage } from '../components/pages/MapPage';
import { SettingPage } from '../components/pages/SettingPage';
import { ViewPage } from '../components/pages/ViewPage';

export const routes = [
  { path: '/', element: <IndexPage /> },
  { path: '/login', element: <LoginPage /> },
  { path: '/map', element: <MapPage /> },
  { path: '/view', element: <ViewPage /> },
  { path: '/setting', element: <SettingPage /> },
];


--- /workspaces/lyssm-ui/frontend/src/services/apiClient.ts ---
import axios from 'axios';

const apiClient = axios.create({
  baseURL: 'http://localhost:8000/api', // APIのベースURL
  timeout: 5000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// 共通のリクエスト・レスポンス処理を追加
apiClient.interceptors.request.use(
  (config) => {
    // 必要に応じてトークンなどのヘッダーを追加
    // config.headers.Authorization = `Bearer ${token}`;
    return config;
  },
  (error) => Promise.reject(error)
);

apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    // エラーハンドリング
    console.error('API Error:', error);
    return Promise.reject(error);
  }
);

export default apiClient;


--- /workspaces/lyssm-ui/frontend/src/services/apiService.ts ---
import { sleep } from '../utils/sleepUtils';
import {
  isLayerDataList,
  isMarkerDataList,
  isSphereDataList,
} from '../utils/typeGuardUtils';
// import apiClient from './apiClient';

// 3. データのキャッシュ戦略
// react-queryを利用してデータのキャッシュや状態管理を行います。これにより、データの再フェッチを最小限に抑えられます。

export const ApiService = {
  async fetchLayers() {
    // const response = await apiClient.get<LayerData[]>('/layers');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch layers');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'layer01',
        name: 'Layer Name 01',
        imageUrl: '/images/layer_sample.PNG',
        createdAt: '2021-01-01T00:00:00',
        updatedAt: '2021-01-02T00:00:00',
      },
      {
        id: 'layer02',
        name: 'Layer Name 02',
        imageUrl: '/images/layer_sample.PNG',
        createdAt: '2021-01-01T00:00:00',
        updatedAt: '2021-01-02T00:00:00',
      },
    ];
    if (!isLayerDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  async fetchMarkers() {
    // const response = await apiClient.get<MarkerData[]>('/markers');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch markers');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'marker01',
        sphereId: 'sphere01',
        name: 'Marker Name 01',
        description: 'This is marker 01',
        orientation: { yaw: 0, pitch: 0 },
        imageUrl: '/images/image-800x600.png',
        thumbnailUrl: '/images/image-160x120.png',
        markerType: 'default',
        createdAt: '2022-01-01T00:00:00',
      },
      {
        id: 'marker02',
        sphereId: 'sphere01',
        name: 'Marker Name 02',
        description: 'This is marker 02',
        orientation: { yaw: 45, pitch: 10 },
        imageUrl: '/images/image-800x600.png',
        thumbnailUrl: '/images/image-160x120.png',
        markerType: 'default',
        createdAt: '2023-01-01T00:00:00',
      },
    ];
    if (!isMarkerDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  async fetchSpheres() {
    // const response = await apiClient.get<SphereData[]>('/spheres');
    // if (!response.ok) {
    //   throw new Error('Failed to fetch spheres');
    // }
    // sonct data = await response.data;
    const data = [
      {
        id: 'sphere01',
        layerId: 'layer01',
        name: 'Sphere Name 01',
        imageUrl: '/images/sphere_sample_01.jpg',
        position: {
          x: 500,
          y: 500,
        },
        createdAt: '2021-02-01T00:00:00',
      },
      {
        id: 'sphere02',
        layerId: 'layer01',
        name: 'Sphere Name 02',
        imageUrl: '/images/sphere_sample_02.JPG',
        position: {
          x: 600,
          y: 500,
        },
        createdAt: '2021-03-01T00:00:00',
      },
      {
        id: 'sphere03',
        layerId: 'layer02',
        name: 'Sphere Name 03',
        imageUrl: '/images/sphere_sample_01.jpg',
        position: {
          x: 500,
          y: 500,
        },
        createdAt: '2021-04-01T00:00:00',
      },
    ];
    if (!isSphereDataList(data)) {
      throw new Error('invalid data format');
    }
    sleep(1000);
    return data;
  },

  // async getSignedUrl(fileId: string) {
  //   const response = await apiClient.get(`/get-signed-url/${fileId}`);
  //   return response.data.url;
  // },
  async getSignedUrl(url: string) {
    return url;
  },
  // 他のAPI呼び出しもここに追加
};


--- /workspaces/lyssm-ui/frontend/src/setupTests.ts ---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


--- /workspaces/lyssm-ui/frontend/src/store/slices/viewerSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { LayerData, MarkerData, SphereData } from '../../types/map';

interface ViewerState {
  isAuthenticated: boolean; // 認証済みかどうか
  isLoading: boolean; // ローディング中かどうか
  isSidebarOpen: boolean; // サイドバーが開いているかどうか
  isMarkerModalOpen: boolean; // マーカーモーダルが開いているかどうか
  selectedLayerId: string | null; // 選択中のレイヤーID
  lastSelectedSphereId: string | null; // 直前に選択したSphereID
  selectedSphereId: string | null; // 選択中のSphereID
  selectedMarkerId: string | null; // 選択中のマーカーID
  layerDataList: LayerData[]; // レイヤーデータリスト
  sphereDataList: SphereData[]; // Sphereデータリスト
  markerDataList: MarkerData[]; // マーカーデータリスト
}

const initialState: ViewerState = {
  isAuthenticated: false,
  isLoading: false,
  isSidebarOpen: false,
  isMarkerModalOpen: false,
  selectedLayerId: null,
  lastSelectedSphereId: null,
  selectedSphereId: null,
  selectedMarkerId: null,
  layerDataList: [],
  sphereDataList: [],
  markerDataList: [],
};

const viewerSlice = createSlice({
  name: 'viewer',
  initialState,
  reducers: {
    setIsAuthenticated: (state, action: PayloadAction<boolean>) => {
      state.isAuthenticated = action.payload;
    },
    setIsLoading: (state, action: PayloadAction<boolean>) => {
      state.isLoading = action.payload;
    },
    toggleSidebar: (state) => {
      state.isSidebarOpen = !state.isSidebarOpen;
    },
    setIsMarkerModalOpen: (state, action: PayloadAction<boolean>) => {
      state.isMarkerModalOpen = action.payload;
    },
    selectLayerId: (state, action: PayloadAction<string | null>) => {
      state.selectedLayerId = action.payload;
    },
    selectLastSphereId: (state, action: PayloadAction<string | null>) => {
      state.lastSelectedSphereId = action.payload;
    },
    selectSphereId: (state, action: PayloadAction<string | null>) => {
      state.selectedSphereId = action.payload;
    },
    selectMarkerId: (state, action: PayloadAction<string | null>) => {
      state.selectedMarkerId = action.payload;
    },
    selectLayerDataList: (state, action: PayloadAction<LayerData[]>) => {
      state.layerDataList = action.payload;
    },
    selectSphereDataList: (state, action: PayloadAction<SphereData[]>) => {
      state.sphereDataList = action.payload;
    },
    selectMarkerDataList: (state, action: PayloadAction<MarkerData[]>) => {
      state.markerDataList = action.payload;
    },
  },
});

export const {
  setIsAuthenticated,
  setIsLoading,
  toggleSidebar,
  setIsMarkerModalOpen,
  selectLayerId,
  selectLastSphereId,
  selectSphereId,
  selectMarkerId,
  selectLayerDataList,
  selectSphereDataList,
  selectMarkerDataList,
} = viewerSlice.actions;

export default viewerSlice.reducer;


--- /workspaces/lyssm-ui/frontend/src/store/store.ts ---
import { configureStore } from '@reduxjs/toolkit'
import viewerReducer from './slices/viewerSlice'

const store = configureStore({
  reducer: {
    viewer: viewerReducer,
  },
})

export type RootState = ReturnType<typeof store.getState>
export type AppDispatch = typeof store.dispatch

export default store


--- /workspaces/lyssm-ui/frontend/src/types/map.d.ts ---
export interface GeoLocation {
  latitude: number;
  longitude: number;
  altitude?: number;
}

export interface Position {
  x: number;
  y: number;
}

export interface Orientation {
  yaw: number;
  pitch: number;
}

// export interface FacilityMarkerData {
//   id: string
//   geoLocation: GeoLocation
//   name: string
//   description: string
//   websiteUrl?: string
//   iconType?: keyof typeof icons // 文字列（アイコン名）で指定
// }

export interface SphereMarkerData {
  geoLocation: GeoLocation;
  name: string;
  description: string;
  iconUrl?: string;
}

export interface LayerData {
  id: string;
  name: string;
  imageUrl: string;
  createdAt: string;
  updatedAt: string;
}

export interface SphereData {
  id: string;
  layerId: string;
  name: string;
  imageUrl: string;
  position: Position;
  createdAt: string;
}

export interface MarkerData {
  id: string;
  sphereId: string;
  name: string;
  description: string;
  orientation: Orientation;
  imageUrl: string;
  thumbnailUrl: string;
  markerType: string;
  createdAt: string;
}


--- /workspaces/lyssm-ui/frontend/src/utils/animationUtils.ts ---
// src/utils/animationUtils.ts
import { Viewer } from '@photo-sphere-viewer/core';

export const animateToMarker = (
  viewer: Viewer,
  yaw: number, // Yaw in degrees
  pitch: number, // Pitch in degrees
  speed: number = 500
) => {
  viewer.animate({
    yaw: (yaw * Math.PI) / 180,
    pitch: (pitch * Math.PI) / 180,
    speed: speed,
  });
};


--- /workspaces/lyssm-ui/frontend/src/utils/sleepUtils.ts ---
export const sleep = (ms: number) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};


--- /workspaces/lyssm-ui/frontend/src/utils/sphereUtils.ts ---
import { Orientation, SphereData } from '../types/map';

interface SphereDataRelative {
  sphereData: SphereData;
  distance: number;
  orientation: Orientation;
}

export const getSphereDataRelative = (
  targetSphere: SphereData,
  selectedSphere: SphereData
): SphereDataRelative => {
  const dx = targetSphere.position.x - selectedSphere.position.x;
  const dy = targetSphere.position.y - selectedSphere.position.y;
  const distance = Math.sqrt(dx ** 2 + dy ** 2);
  if (distance === 0) {
    return {
      sphereData: targetSphere,
      distance,
      orientation: { yaw: 0, pitch: 0 },
    };
  }
  const orientation: Orientation = {
    yaw: Math.atan2(dx, -dy) * (180 / Math.PI),
    pitch: 0.0 * (180 / Math.PI),
  };
  return { sphereData: targetSphere, distance, orientation };
};

export const getNearestSpheres = (
  spheres: SphereData[],
  selectedSphere: SphereData,
  radius: number = 1000
): SphereDataRelative[] => {
  // selectedSphereからの距離と方向を計算
  const targetSpheres: SphereData[] = spheres.filter(
    (sphereData) =>
      sphereData.layerId === selectedSphere.layerId &&
      sphereData !== selectedSphere
  );
  const sphereDataRelatives: SphereDataRelative[] = targetSpheres.map(
    (sphereData) => {
      return getSphereDataRelative(sphereData, selectedSphere);
    }
  );

  // distanceに応じてソート
  sphereDataRelatives.sort((a, b) => a.distance - b.distance);

  // radius以内のSphereを取得
  var nearestSpheres: SphereDataRelative[] = [];
  for (const sphereDataRelative of sphereDataRelatives) {
    if (
      sphereDataRelative.distance <= radius &&
      sphereDataRelative.sphereData !== selectedSphere &&
      sphereDataRelative.sphereData.layerId === selectedSphere.layerId
    ) {
      nearestSpheres.push(sphereDataRelative);
    }
  }

  // yaw, pitchで5度以内のsphereは除外
  var filteredSpheres: SphereDataRelative[] = [];
  for (const sphereDataRelative of nearestSpheres) {
    var isNear = false;
    for (const filteredSphere of filteredSpheres) {
      const dy =
        sphereDataRelative.orientation.yaw - filteredSphere.orientation.yaw;
      const dp =
        sphereDataRelative.orientation.pitch - filteredSphere.orientation.pitch;
      const criterionDegrees = 5;
      if (dy < criterionDegrees || dp < criterionDegrees) {
        isNear = true;
        break;
      }
    }
    if (!isNear) {
      filteredSpheres.push(sphereDataRelative);
    }
  }

  return filteredSpheres;
};


--- /workspaces/lyssm-ui/frontend/src/utils/typeGuardUtils.ts ---
// src/utils/typeGuards.ts
import { LayerData, MarkerData, SphereData } from '../types/map';

export function isLayerDataList(data: any): data is LayerData[] {
  return (
    Array.isArray(data) && data.every((item) => 'id' in item && 'name' in item)
  );
}

export function isMarkerDataList(data: any): data is MarkerData[] {
  return (
    Array.isArray(data) &&
    data.every((item) => 'id' in item && 'name' in item && 'sphereId' in item)
  );
}

export function isSphereDataList(data: any): data is SphereData[] {
  return (
    Array.isArray(data) &&
    data.every((item) => 'id' in item && 'name' in item && 'layerId' in item)
  );
}


--- /workspaces/lyssm-ui/frontend/src/utils/viewerUtils.ts ---
import { Position, Viewer } from '@photo-sphere-viewer/core';
import { Orientation } from '../types/map';

export const getOrientation = (viewer: Viewer | null) => {
  if (!viewer) return { yaw: 0, pitch: 0 };
  const position: Position = viewer.getPosition();
  if (!position) return { yaw: 0, pitch: 0 };
  const orientation: Orientation = {
    yaw: (position.yaw * 180) / Math.PI,
    pitch: (position.pitch * 180) / Math.PI,
  };
  return orientation;
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/LayerViewerViewModel.ts ---
import { useDispatch, useSelector } from 'react-redux';
import { selectSphereId, toggleSidebar } from '../store/slices/viewerSlice';
import { RootState } from '../store/store';

export const useLayerViewerViewModel = () => {
  const dispatch = useDispatch();
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const isSidebarOpen = useSelector(
    (state: RootState) => state.viewer.isSidebarOpen
  );

  const selectedLayer = layerDataList.find(
    (layer) => layer.id === selectedLayerId
  );

  // Sphereのピンをクリックしたときの処理
  const handleSphereClick = (sphereId: string) => {
    dispatch(selectSphereId(sphereId));
  };

  const handleToggleSidebar = () => {
    dispatch(toggleSidebar());
  };

  return {
    selectedLayer,
    sphereDataList,
    handleSphereClick,
    isSidebarOpen,
    handleToggleSidebar,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/MarkerModalViewModel.ts ---
import { useEffect } from 'react';

export const useMarkerModalViewModel = (onClose: () => void) => {
  // ESCキーでモーダルを閉じる
  useEffect(() => {
    const handleEsc = (event: KeyboardEvent) => {
      if (event.key === 'Escape') {
        onClose();
      }
    };
    document.addEventListener('keydown', handleEsc);

    return () => {
      document.removeEventListener('keydown', handleEsc);
    };
  }, [onClose]);
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/PanoramaViewerViewModel.tsx ---
// react
import { useEffect, useRef, useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
// global state
import {
  selectLastSphereId,
  selectLayerId,
  selectMarkerId,
  selectSphereId,
  setIsMarkerModalOpen,
  toggleSidebar,
} from '../store/slices/viewerSlice';
import { RootState } from '../store/store';
// model
import { PanoramaViewerModel } from '../models/PanoramaViewerModel';
import { Orientation } from '../types/map';
// utils
import ReactDOMServer from 'react-dom/server';
import { CustomTooltip } from '../components/molecules/CustomTooltip';
import { getOrientation } from '../utils/viewerUtils';

export const usePanoramaViewerViewModel = (isDesktop: boolean) => {
  const dispatch = useDispatch();
  const viewerRef = useRef<HTMLDivElement | null>(null);
  const panoramaViewerModelRef = useRef<PanoramaViewerModel | null>(null);

  const isSidebarOpen = useSelector(
    (state: RootState) => state.viewer.isSidebarOpen
  );
  const isMarkerModalOpen = useSelector(
    (state: RootState) => state.viewer.isMarkerModalOpen
  );
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const lastSelectedSphereId = useSelector(
    (state: RootState) => state.viewer.lastSelectedSphereId
  );
  const selectedSphereId = useSelector(
    (state: RootState) => state.viewer.selectedSphereId
  );
  const selectedMarkerId = useSelector(
    (state: RootState) => state.viewer.selectedMarkerId
  );
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const markerDataList = useSelector(
    (state: RootState) => state.viewer.markerDataList
  );
  const [currentOrientation, setCurrentOrientation] = useState<Orientation>({
    yaw: 0.0,
    pitch: 0.0,
  });

  const handleToggleSidebar = () => {
    dispatch(toggleSidebar());
  };

  // 選択されたマーカーのデータ
  const selectedMarkerData = markerDataList.find(
    (marker) => marker.id === selectedMarkerId
  );

  // ツールチップの内容をView側で作成
  const markerTooltipContents = markerDataList.reduce(
    (contents, marker) => {
      const tooltipContent = ReactDOMServer.renderToStaticMarkup(
        <CustomTooltip markerData={marker} key={marker.id} />
      );
      contents[marker.id] = tooltipContent;
      return contents;
    },
    {} as { [key: string]: string }
  );

  // Viewerの初期化
  useEffect(() => {
    if (!viewerRef.current) return;

    panoramaViewerModelRef.current = new PanoramaViewerModel();
    panoramaViewerModelRef.current.initializeViewer(
      viewerRef.current,
      isDesktop
    );

    // ビューアのイベントリスナーを設定
    const viewerInstance = panoramaViewerModelRef.current.viewerInstance;
    const mapPlugin = panoramaViewerModelRef.current.mapPlugin;
    const markersPlugin = panoramaViewerModelRef.current.markersPlugin;

    // マーカークリック時の処理
    markersPlugin?.addEventListener('select-marker', ({ marker }) => {
      // マーカーがSphereかどうか判定
      const selectedSphere = sphereDataList.find(
        (sphere) => sphere.id === marker.id
      );
      if (selectedSphere) {
        dispatch(selectSphereId(marker.id));
        dispatch(selectMarkerId(null));
        return;
      }
      // マーカーがMarkerかどうか判定
      const selectedMarker = markerDataList.find(
        (_marker) => _marker.id === marker.id
      );
      if (selectedMarker) {
        dispatch(selectMarkerId(marker.id));
        dispatch(setIsMarkerModalOpen(true));
      }
    });

    // ホットスポットクリック時の処理
    mapPlugin?.addEventListener('select-hotspot', ({ hotspotId }) => {
      dispatch(selectSphereId(hotspotId));
    });

    // YawとPitchの更新（デスクトップのみ）
    if (isDesktop) {
      const updateOrientation = () => {
        const orientation = getOrientation(viewerInstance);
        setCurrentOrientation({ ...orientation });
        requestAnimationFrame(updateOrientation);
      };
      updateOrientation();
    }

    return () => {
      viewerInstance?.destroy();
    };
  }, [markerDataList, sphereDataList, layerDataList, isDesktop]);

  // Layerの変更時
  // 監視対象: selectedLayerId, layerDataList
  useEffect(() => {
    if (!selectedLayerId || !panoramaViewerModelRef.current) return;

    const selectedLayer = layerDataList.find(
      (layer) => layer.id === selectedLayerId
    );
    if (!selectedLayer) return;

    panoramaViewerModelRef.current.handleLayerChange(
      selectedLayer,
      sphereDataList
    );
  }, [selectedLayerId, layerDataList, sphereDataList]);

  // Sphereの変更時
  // 監視対象: selectedSphereId, sphereDataList, markerDataList, layerDataList
  useEffect(() => {
    if (!selectedSphereId || !panoramaViewerModelRef.current) return;

    const selectedSphere = sphereDataList.find(
      (sphere) => sphere.id === selectedSphereId
    );
    if (!selectedSphere) return;

    const lastSelectedSphere = sphereDataList.find(
      (sphere) => sphere.id === lastSelectedSphereId
    );

    const selectedLayer = layerDataList.find(
      (layer) => layer.id === selectedSphere.layerId
    );
    if (!selectedLayer) return;

    const layerChanged = selectedLayerId !== selectedLayer.id;

    if (layerChanged) {
      dispatch(selectLayerId(selectedLayerId));
    }

    panoramaViewerModelRef.current.handleSphereChange(
      selectedSphere,
      lastSelectedSphere || null,
      layerChanged
    );

    dispatch(selectLastSphereId(selectedSphere.id));

    // マーカーとマップの更新
    panoramaViewerModelRef.current.updateMarkersAndMap(
      selectedSphere,
      sphereDataList,
      markerDataList,
      markerTooltipContents
    );
  }, [selectedSphereId, markerDataList, sphereDataList, layerDataList]);

  // Markerの変更時
  // 監視対象: selectedMarkerId, markerDataList
  useEffect(() => {
    if (!selectedMarkerId || !panoramaViewerModelRef.current) return;

    const selectedMarker = markerDataList.find(
      (marker) => marker.id === selectedMarkerId
    );
    if (!selectedMarker) return;

    panoramaViewerModelRef.current.handleMarkerChange(selectedMarker);
  }, [selectedMarkerId, markerDataList]);

  // MarkerModalを閉じる処理
  const handleCloseMarkerModal = () => {
    dispatch(setIsMarkerModalOpen(false));
  };

  return {
    viewerRef,
    currentOrientation,
    isSidebarOpen,
    isMarkerModalOpen,
    handleToggleSidebar,
    selectedMarkerData,
    handleCloseMarkerModal,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/SidebarTreeViewModel.ts ---
// src/viewModels/SidebarTreeViewModel.ts
import { useDispatch, useSelector } from 'react-redux';
import {
  selectLayerId,
  selectMarkerId,
  selectSphereId,
} from '../store/slices/viewerSlice';
import { RootState } from '../store/store';

export const useSidebarTreeViewModel = () => {
  const dispatch = useDispatch();
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const markerDataList = useSelector(
    (state: RootState) => state.viewer.markerDataList
  );

  const handleItemClick = (
    event: React.SyntheticEvent<Element, Event>,
    itemId: string
  ) => {
    const selectedLayer = layerDataList.find((layer) => layer.id === itemId);
    if (selectedLayer) {
      dispatch(selectLayerId(itemId));
      dispatch(selectSphereId(null));
      dispatch(selectMarkerId(null));
      return;
    }

    const selectedSphere = sphereDataList.find(
      (sphere) => sphere.id === itemId
    );
    if (selectedSphere) {
      dispatch(selectLayerId(selectedSphere.layerId));
      dispatch(selectSphereId(itemId));
      dispatch(selectMarkerId(null));
      return;
    }

    const selectedMarker = markerDataList.find(
      (marker) => marker.id === itemId
    );
    if (selectedMarker) {
      const sphereOfMarker = sphereDataList.find(
        (sphere) => sphere.id === selectedMarker.sphereId
      );
      dispatch(selectLayerId(sphereOfMarker!.layerId));
      dispatch(selectSphereId(selectedMarker.sphereId));
      dispatch(selectMarkerId(itemId));
    }
  };

  return {
    handleItemClick,
  };
};


--- /workspaces/lyssm-ui/frontend/src/viewModels/TreeListViewModel.ts ---
import { useSelector } from 'react-redux';
import { RootState } from '../store/store';

export const useTreeListViewModel = () => {
  const layerDataList = useSelector(
    (state: RootState) => state.viewer.layerDataList
  );
  const sphereDataList = useSelector(
    (state: RootState) => state.viewer.sphereDataList
  );
  const markerDataList = useSelector(
    (state: RootState) => state.viewer.markerDataList
  );
  const selectedLayerId = useSelector(
    (state: RootState) => state.viewer.selectedLayerId
  );
  const selectedSphereId = useSelector(
    (state: RootState) => state.viewer.selectedSphereId
  );
  const selectedMarkerId = useSelector(
    (state: RootState) => state.viewer.selectedMarkerId
  );

  return {
    layerDataList,
    sphereDataList,
    markerDataList,
    selectedLayerId,
    selectedSphereId,
    selectedMarkerId,
  };
};

